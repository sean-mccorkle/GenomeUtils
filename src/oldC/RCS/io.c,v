head	3.9;
access;
symbols;
locks
	mccorkle:3.9; strict;
comment	@ * @;


3.9
date	2000.03.16.19.48.30;	author mccorkle;	state Exp;
branches;
next	3.8;

3.8
date	97.04.22.01.30.22;	author mccorkle;	state Exp;
branches;
next	3.7;

3.7
date	97.03.15.22.31.34;	author mccorkle;	state Exp;
branches;
next	3.6;

3.6
date	97.02.24.17.04.56;	author mccorkle;	state Exp;
branches;
next	3.5;

3.5
date	97.02.15.19.34.47;	author mccorkle;	state Exp;
branches;
next	3.4;

3.4
date	97.01.08.03.40.17;	author mccorkle;	state Exp;
branches;
next	3.3;

3.3
date	97.01.08.03.23.55;	author mccorkle;	state Exp;
branches;
next	3.2;

3.2
date	96.10.07.19.04.10;	author mccorkle;	state Exp;
branches;
next	3.1;

3.1
date	96.09.20.03.22.17;	author mccorkle;	state Exp;
branches;
next	3.0;

3.0
date	96.09.17.17.57.36;	author mccorkle;	state Exp;
branches;
next	;


desc
@Routines for handling sequence io
@


3.9
log
@Many differences - dusting this off and porting to linux
@
text
@/* Module:       io.c                                                */
/* Programmer:   Sean R. McCorkle                                    */
/* Language:     C                                                   */
/* Description:  Routines for handling sequence I/O.                 */
/*                                                                   */
/* $Id: io.c,v 3.8 1997/04/22 01:30:22 mccorkle Exp mccorkle $       */
/*********************************************************************/


static char io_rcs_id[] =
      "$Id: io.c,v 3.8 1997/04/22 01:30:22 mccorkle Exp mccorkle $";

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "seqlib.h"


void  make_char_set_index( char *str, char *char_set );
void  get_seq_buff( int s );
int   get_next_char_from_seqbuff( int s );
void  tab( FILE *output, int n );

/* array (hopefully small!) of buffers, flags, etc for handling multiple */
/* open sequence files.                                                  */

#define MAX_OPEN_SEQF  5

char   *seq_buff[MAX_OPEN_SEQF];
int     at_eof[MAX_OPEN_SEQF];
char   *next_p[MAX_OPEN_SEQF];
int     in_use[MAX_OPEN_SEQF] = { 0, 0, 0, 0, 0 };
FILE   *seqf[MAX_OPEN_SEQF];
char   *seqfilename[MAX_OPEN_SEQF];
char    lineno[MAX_OPEN_SEQF];
char    is_allowed[MAX_OPEN_SEQF][NUM_CHARS];
char    is_ignored[MAX_OPEN_SEQF][NUM_CHARS];

/*************************************************************************/
/* Open a sequence file for reading by load_sequence() and load_header.  */
/* At the same time, establish which chars are allowed and which ignored */
/* returns a integer file specifier which is passed as an argument to    */
/* those routines, or -1 if an error occurs.  If filename is "-", then   */
/* stdin is used.                                                        */
/* Let the user beware:  if allowed and ignored share a character, its   */
/* trouble!                                                              */
/*************************************************************************/

int  open_seqf( char *filename,
                char *allowed,  /* input; legal chars for seq, ie. "acgt" */
                char *ignored   /* input; chars to ignore, ie. "\n\t"     */
              )

   {
    int s = 0;

    while ( s < MAX_OPEN_SEQF && in_use[s] )
        s++;
    if ( s >= MAX_OPEN_SEQF )
       {
        errno = ENOSR;
        return( -1 );
       }
    if ( strcmp( filename, "-" ) == 0 )
       {
        seqf[s] = stdin;
        seqfilename[s] = strdup( "- (stdin)" );
       }
    else
       {
        if ( ! ( seqf[s] = fopen( filename, "r" ) ) )
            return( -1 );
        seqfilename[s] = strdup( filename );
       }
    seq_buff[s] = (char *) malloc( MAX_LINE_LENGTH );
    *seq_buff[s] = '\0';              /* indicates "no data yet"      */
    next_p[s] = seq_buff[s];          /* also indicates "no data yet  */
    make_char_set_index( allowed, is_allowed[s] );
    make_char_set_index( ignored, is_ignored[s] );
    in_use[s] = 1;
    at_eof[s] = 0;
    lineno[s] = 0;
    return( s );
   }

/****************************************************/
/* close a sequence channel (freeing it for re-use) */
/****************************************************/

int  close_seqf( int s )
   {
    if ( s >= 0 && s < MAX_OPEN_SEQF )
       {
        free( seq_buff[s] );
        free( seqfilename[s] );
        in_use[s] = 0;
        return( 1 );
       }
    else
        return( 0 );
   }

/* call free_lines() to free all the storage allocated for the lines */
/* *nlines = 0 if no header was read                                 */

void load_header( int s, int *nlines, char ***lines )

   {
    static   char *loclines[MAX_HEADER_LINES];
    int      n = 0;

    if ( ! *seq_buff[s] )          /* if theres nothing in buffer, read */
        get_seq_buff( s );         /* first line                        */

    while ( (! at_eof[s] ) && n < MAX_HEADER_LINES && 
         ( *seq_buff[s] == '>' || *seq_buff[s] == ';' || blank( seq_buff[s] )))
       {
        if ( *seq_buff[s] == '>' || *seq_buff[s] == ';' )
            loclines[n++] = strdup( seq_buff[s] );
        get_seq_buff( s );                      /* get new line */
       }
    if ( n >= MAX_HEADER_LINES )
       {
        fprintf( stderr, 
                 "%s (load_header): file %s header exceeds %d lines\n", 
                 progname, seqfilename[s], MAX_HEADER_LINES );
        exit( 1 );
       }
    *nlines = n;
    if ( n < 1 )
        *lines = (char **) 0;
    else
       {
        *lines = (char **) malloc( n * sizeof( char * ) );
        while ( n-- > 0 )
            (*lines)[n] = loclines[n];
       }
   }


void skip_header( int s )

   {
    if ( ! *seq_buff[s] )       /* if theres nothing in buffer, read */
        get_seq_buff( s );      /* first line                        */

    while ( (! at_eof[s]) && 
       ( *seq_buff[s] == '>' || *seq_buff[s] == ';' || blank( seq_buff[s] ) ) )
        get_seq_buff( s );
   }

/* Frees all memory allocated for a lines structure, like that returned  */
/* by load_header()                                                      */

void free_lines( int nlines, char **lines )

   {
    while ( nlines-- > 0 )
        free( lines[nlines] );
    if ( lines )
        free( lines );
   }


/***************************************************************************/
/* load sequence - reads one of our modified FASTA-style ascii sequence    */
/* files, globbing in the entire sequence in one shot.                     */
/* Returns -1 if an error occured (sequence length exceeds max_seq_size)   */
/*          0 if no sequence was read (EOF) encountered                    */
/*          1 if a sequence was read successfully                          */
/* returns number of characters in sequence read (not counting ignored     */
/* characters.  0 means no characters read, -1 if sequence length exceeds  */
/* max_seq_size or if a character was read which is not in the allowed     */
/* set string, or the ignored set string                                   */
/***************************************************************************/

int load_seq( int   s,        /* input; input seq file desc (from open_seqf) */
              int   max_seq_size, /* input; size of seq array                */
              char *seq,      /* output; where to place output sequence      */
	      int  *seq_len   /* output; actual length read                  */
            )  

   {
    int        c;
    int        n;

    n = 0;
    while ( ( n < max_seq_size ) && 
            ( c = get_next_sequence_char( s ) ) &&
            c != ERROR && c != EOF )
       {
        n++;
        *seq++ = (char) c;
       }

    if ( n >= max_seq_size )
       {
        fprintf( stderr, "%s: input sequence in file too long! (> %d)\n", 
                 progname, seqfilename[s], max_seq_size );
        return( -1 );
       }
    if ( c == ERROR )
        return( -1 );
    if ( (c == EOF || c == 0) && n == 0 )
        return( 0 );
    *seq = '\0';
    *seq_len = n;
    return( 1 );
   }

/* returns EOF, ERROR, '\0' or the next allowed character (removes ignoreds) */

int  get_next_sequence_char( int s )
   {
    int c;

    do {
        c = get_next_char_from_seqbuff( s );
       }
    while ( c && c != EOF && is_ignored[s][(char) c] );

    if ( ( ! c ) || c == EOF )
        return( c );

    if ( is_allowed[s][(char) c] )
        return( c );
    else
       {
        fprintf( stderr,
           "%s: bad character \"%c\" (%x hex) in sequence file %s, line %d\n", 
           progname, (char) c, c, seqfilename[s], lineno[s] );
        return( ERROR );
       }
   }

/* return the next raw character sitting in the buffer for channel s.  Reload*/
/* the buffer if necessary. returns EOF if end of file is hit on reload,     */
/* 0 if the buffer reload gets a next header ("> ") line, or the             */
/* actual raw character.  This skips past comment lines ("; ")               */

int  get_next_char_from_seqbuff( int s )
   {
    if ( at_eof[s] )
        return( EOF );

    if ( (! *next_p[s]) || next_p[s] > seq_buff[s] + MAX_LINE_LENGTH )
       {
        do {
            get_seq_buff( s );
           }
        while ( (! at_eof[s]) && *seq_buff[s] == ';' );

        if ( at_eof[s] )
            return( EOF );
        if ( *seq_buff[0] == '>' )
            return( '\0' );
       }
    return( *(next_p[s])++ );
   }


/*****************************************************************************/
/* get_seq_buff( s ) - read another line from file desc s (from open_seqf),  */
/* into seq_buff for file s.                                                 */
/* set global boolean at_eof[s] when end-of-file is encountered.             */
/* Note: this doesn't handle lines longer than MAX_LINE_LENGTH properly!     */
/*       FIX!  Put in error handling here!                                   */
/*****************************************************************************/

void  get_seq_buff( int s )

   {
    if ( at_eof[s] )
        return;

    if ( ! fgets( seq_buff[s], MAX_LINE_LENGTH, seqf[s] ) )
       {
#ifdef DEBUG
        printf( "get_seq_buff: eof, line_no %d\n", lineno[s] );
#endif
        at_eof[s] = 1;
        return;
       }
    next_p[s] = seq_buff[s];
    lineno[s]++;
#ifdef DEBUG
    printf( "get_seq_buff: line %d [%s] (%d)\n", 
              lineno[s], seq_buff[s], at_eof[s] );
#endif
   }


void print_lines( FILE *output, int nlines, char **lines )

   {
    int  i;
    for ( i = 0; i < nlines; i++ )
        fputs( lines[i], output );
   }


/* print_seq( f, seq, start, stop, indent, linelen, spaces, xtralines       */
/*                                                                          */
/*     f     - (input) file output goes to                                  */
/*                                                                          */
/*  Input Sequence Parameters                                               */
/*                                                                          */
/*  seq   - (input) sequence string                                         */
/*  start - (input) index of string to start printing at (default = 0)      */
/*  stop  - (input) index of last character in string to print (defaults    */
/*                  to full string)                                         */
/*                                                                          */
/*  Output Sequence Parameters                                              */
/*                                                                          */
/*  indent    - (input) spaces to indent at the beginning of each line      */
/*  linelen   - (input) characters per line of output (not including indent */
/*                      or spaces (0 defaults to 60)                        */
/*  spaces    - (input) num characters between spaces                       */
/*                      (0 or >linelen means no spaces at all)              */
/*  xtralines - (input) number of extra blank line                          */
/* */

void  print_seq( FILE *output, char *seq, int start, int stop, int indent,
                 int linelen, int spaces, int xtralines
               )

   {
    int  n, i, j;

    n = strlen( seq );
    if ( start < 1 )
        start = 1;
    if ( stop < 1 || stop > n )
        stop = n;
#ifdef DEBUG
    printf( "start is %d\n", start );
#endif
    tab( output, indent );
    for ( j = 1, i = start - 1; i < stop; i++, j++ )
       {
        putc( seq[i], output );
        if ( (j % linelen) == 0 )
	   {
            putc( '\n', output );
            tab( output, indent );
	   }
        else if ( (j % 10) == 0 )
            putc( ' ', output );
       }
    if ( (j-1) % 60 )
        putc( '\n', output );
   }

void tab ( FILE *output, int n )
   {
    while ( n-- > 0 )
        putc( ' ', output );
   }

int count_char_occurrences( char *set, char *seq, int start, int stop )

   {
    static char  is_in_set[NUM_CHARS];
    char        *s, *s_end;
    int          n = 0, len;

    len = strlen( seq );
    if ( start < 1 )
        start = 1;
    s = seq + start - 1;
    if ( stop < 1 || stop > len )
        stop = len;
    s_end = seq + stop;
    make_char_set_index( set, is_in_set );    
    while ( *s && s < s_end )
        if ( is_in_set[ *s++ ] )
            n++;
    return( n );
   }

/* convert a string set into a character lookup table for fast  */
/* evaluation of whether or not a character is present in a set */
/* (If str is 0, set is empty) */

void make_char_set_index( char *str, char *char_set )

   {
    memset( char_set, 0, NUM_CHARS );
    if ( str )
        while ( *str )
            char_set[ *str++ ] = 1;
   }


@


3.8
log
@Restructuring: non labdb specific routines moved into libseq.a
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.7 1997/03/15 22:31:34 mccorkle Exp mccorkle $       */
d11 1
a11 1
      "$Id: io.c,v 3.7 1997/03/15 22:31:34 mccorkle Exp mccorkle $";
a19 1
#define NUM_CHARS 256   /* size of char set lookup tables */
d23 1
d33 1
d37 18
a54 9

/************************************************************************/
/* Open a sequence file for reading by load_sequence() and load_header. */
/* returns a integer file specifier which is passed as an argument to   */
/* those routines, or -1 if an error occurs.  If filename is "-", then  */
/* stdin is used.                                                       */
/************************************************************************/

int  open_seqf( char *filename )
d78 4
a81 1
    *seq_buff[s] = '\0';  /*  indicates "no data yet" */
d84 1
d88 4
d169 1
a169 1
/* files.                                                                  */
a179 2
              char *allowed,  /* input; string of legal chars for seq "acgt" */
              char *ignored,  /* input; string of chars to ignore "\n\t"     */
d186 11
a196 31
    static char  is_allowed[NUM_CHARS];
    static char  is_ignored[NUM_CHARS];
    char        *c;

    make_char_set_index( allowed, is_allowed );
    make_char_set_index( ignored, is_ignored );
    
    if ( ! *seq_buff[s] )        /* if theres nothing in buffer, read */
        get_seq_buff( s );       /* first line                        */

    *seq_len = 0;
    /* Note: totally blank lines are ignored (regardless of char set) */
    while ( (! at_eof[s])  && *seq_len < max_seq_size &&
               *seq_buff[s] != '>' && *seq_buff[s] != ';' )
       {
        if ( ! blank( seq_buff[s] ) )
            for ( c = seq_buff[s]; *seq_len < max_seq_size && *c; c++ )
                if ( is_allowed[ *c ] )
         	   {
                    (*seq_len)++;
                    *seq++ = *c;
                   }
                else if ( ! is_ignored[ *c ] )
         	   {
                    fprintf( stderr, 
                     "%s: input char [%c] in file %s not in allowed [%s] or ignored [%s] sets\n", 
                             progname, *c, seqfilename[s], allowed, ignored );
                    return( -1 );
                   }
       get_seq_buff( s );
      }
d198 1
a198 1
    if ( *seq_len >= max_seq_size )
d204 4
d209 2
a210 1
    return( *seq_len > 0 );
d213 49
d279 4
d284 4
d289 2
a290 1
    printf( "[%s] (%d)\n", seq_buff[s], at_eof[s] );
d304 24
a327 1
void print_seq( FILE *output, char *seq, int start, int stop, int indent )
d344 1
a344 1
        if ( (j % 60) == 0 )
d352 1
a352 1
    if ( j % 60 )
@


3.7
log
@Modified open_seqf() so that a file name "-" causes stdin
to be used.
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.6 1997/02/24 17:04:56 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.6 1997/02/24 17:04:56 mccorkle Exp mccorkle $";
d18 1
a18 2
#include "labdb.h"
#include "labdb_int.h"
@


3.6
log
@Finally bit the bullet and adapted the load_seq routines to handle
multiple open files, so now theres open_seqf() and close_seqf()
which return integer descriptors that get passed to load_header(0
and load_seq().
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.5 1997/02/15 19:34:47 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.5 1997/02/15 19:34:47 mccorkle Exp mccorkle $";
d38 7
d57 11
a67 2
    if ( ! ( seqf[s] = fopen( filename, "r" ) ) )
        return( -1 );
a71 1
    seqfilename[s] = strdup( filename );
@


3.5
log
@Tried to clean up the load_header() and load_seq() routines, to let
them handle multiple sequence files.  ALso added skip_header().
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.4 1997/01/08 03:40:17 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.4 1997/01/08 03:40:17 mccorkle Exp mccorkle $";
d14 1
d24 1
a24 1
void  get_seq_buff( FILE *input );
d27 2
d30 1
a30 2
char   seq_buff[MAX_LINE_LENGTH] = { 0 };
int    at_eof = 0;
d32 41
d76 1
a76 1
void load_header( FILE *input, int *nlines, char ***lines )
d82 2
a83 2
    if ( ! *seq_buff )             /* if theres nothing in buffer, read */
        get_seq_buff( input );     /* first line                        */
d85 2
a86 2
    while ( (! at_eof) && n < MAX_HEADER_LINES && 
           ( seq_buff[0] == '>' || seq_buff[0] == ';' || blank( seq_buff ) ) )
d88 3
a90 3
        if ( seq_buff[0] == '>' || seq_buff[0] == ';' )
            loclines[n++] = strdup( seq_buff );
        get_seq_buff( input );                      /* get new line */
d94 3
a96 2
        fprintf( stderr, "%s (load_header): header exceeds %d lines\n", 
                         progname, MAX_HEADER_LINES );
d111 1
a111 1
void skip_header( FILE *input )
d114 2
a115 2
    if ( ! *seq_buff )             /* if theres nothing in buffer, read */
        get_seq_buff( input );     /* first line                        */
d117 3
a119 3
    while ( (! at_eof) && 
            ( seq_buff[0] == '>' || seq_buff[0] == ';' || blank( seq_buff ) ) )
        get_seq_buff( input );
d147 1
a147 1
int load_seq( FILE *input,    /* input; input stream to get chars from       */
d158 1
a158 1
    char        *s;
d163 2
a164 2
    if ( ! *seq_buff )             /* if theres nothing in buffer, read */
        get_seq_buff( input );     /* first line                        */
d168 2
a169 2
    while ( (! at_eof)  && *seq_len < max_seq_size &&
               seq_buff[0] != '>' && seq_buff[0] != ';' )
d171 3
a173 3
        if ( ! blank( seq_buff ) )
            for ( s = seq_buff; *seq_len < max_seq_size && *s; s++ )
                if ( is_allowed[ *s ] )
d176 1
a176 1
                    *seq++ = *s;
d178 1
a178 1
                else if ( ! is_ignored[ *s ] )
d181 2
a182 2
                     "%s: input char [%c] not in allowed [%s] or ignored [%s] sets\n", 
                             progname, *s, allowed, ignored );
d185 1
a185 1
       get_seq_buff( input );
d190 2
a191 2
        fprintf( stderr, "%s: input sequence too long! (> %d)\n", 
                 progname, max_seq_size );
d201 3
a203 2
/* get_seq_buff() - read another line into the seq_buff.                     */
/* set global boolean "at_eof" when end-of-file is encountered.              */
d208 1
a208 1
void  get_seq_buff( FILE *input )
d211 1
a211 1
    if ( at_eof )
d214 2
a215 2
    if ( ! fgets( seq_buff, MAX_LINE_LENGTH, input ) )
        at_eof = 1;
d217 1
a217 1
    printf( "[%s] (%d)\n", seq_buff, at_eof );
@


3.4
log
@Added free_lines().
Removed some debug io and streamlined some code.
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.3 1997/01/08 03:23:55 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.3 1997/01/08 03:23:55 mccorkle Exp mccorkle $";
d23 1
a23 4
void  init_input( void );
void  reset_input( void );
char  get_next_char( FILE *input );
int   get_seq_buff( FILE *input );
a25 2
/* This system really ought to be reworked to handle multiple sequences */
/* in a file */
d27 2
a28 3
/* returns number of lines read in header, 0 if none, -1 for error   */
/* uses the seq_buff input, so the first non-header line encountered */
/* is left sitting in the buffer waiting for load_seq().             */
a29 8
/* puke: really ugly because it accesses the seq_buff directly.  I really */
/* should clean this up.                                                  */

char   seq_buff[MAX_LINE_LENGTH];
char  *next_seq_char;
int    at_eof;                /* first eof or error sets this */


d31 1
d37 1
a37 1
    int  n = 0;
d39 5
a43 3
    init_input();
    while ( get_seq_buff( input ) && 
            ( seq_buff[0] == '>' || seq_buff[0] == ';' || blank( seq_buff ) ) )
d47 1
a47 1
        seq_buff[0] = '\0';
d49 6
d56 8
a63 3
    *lines = (char **) malloc( n * sizeof( char * ) );
    while ( n-- > 0 )
        (*lines)[n] = loclines[n];
d66 12
d85 3
a87 2
       free( lines[nlines] );
    free( lines );
d90 7
a96 1
/* load sequence */
d99 1
a99 1
/* MAX_SEQ_LENGTH or if a character was read which is not in the allowed   */
d101 1
a102 1

d106 3
a108 1
              char *seq       /* output; where to place output sequence      */
d114 1
a114 2
    char        *seq_end = seq + MAX_SEQ_LENGTH;
    int          n = 0;
d116 5
a120 2
    make_char_set_index( allowed, is_allowed );    
    make_char_set_index( ignored, is_ignored );    
d122 4
a125 15
    while ( seq < seq_end && (*seq = get_next_char(input)) != EOF )
        if ( is_allowed[ *seq ] )
 	   {
            n++;
            seq++;
           }
        else if ( ! is_ignored[ *seq ] )
 	   {
            fprintf( stderr, 
             "%s: input char [%c] not in allowed [%s] or ignored [%s] sets\n", 
                     progname, *seq, allowed, ignored );
            return( -1 );
           }
    *seq = '\0';
    if ( seq >= seq_end )
d127 21
a147 1
        fprintf( stderr, "%s: input sequence too long!\n", progname );
d150 2
a151 1
    return( n );
a155 35
/**************************************************************************/
/* init_input() simply resets the input buffer for the load_seq input by */
/* clearing the next_seq_char value to force a get_seq_buff() at the next */
/* call to get_next_char()                                                */
/**************************************************************************/

void  init_input( void )

   {
    seq_buff[0] = '\0';
    next_seq_char = seq_buff;
    at_eof = 0;
   }

char get_next_char( FILE *input )

   {
    if ( ! *next_seq_char )
        if ( ! get_seq_buff( input ) )
            return( EOF );
    return( *next_seq_char++ );
   }

/***************************************************************************/
/* reset_input() moves the input pointer back to the begining of the buff, */
/* allowing the next get_next_char() read to start from the beginning of   */
/* the line again.                                                         */
/***************************************************************************/

void  reset_input( void )

   {
    next_seq_char = seq_buff;
   }

d157 2
a158 2
/* get_seq_buff() - read another line into the seq_buff.  Read another if    */
/* the line is whitespace.   Return 1 if theres data, 0 otherwise            */
d160 1
a160 1
/*       FIX!                                                                */
a161 1
/* Put in error handling here! */
d163 1
a163 1
int  get_seq_buff( FILE *input )
d166 2
a167 1
    char *ret;
d169 2
a170 10
    if ( at_eof )
       {
        seq_buff[0] = '\0';
        return( 0 );
       }
    next_seq_char = seq_buff;
    do {
        ret = fgets( seq_buff, MAX_LINE_LENGTH, input );
        if ( ! ret )
            at_eof = 1;
d172 1
a172 4
        if ( ret )
            printf( "get_seq_buff: [%s]\n", seq_buff );
        else
            printf( "get_seq_buff: EOF or something\n" );
a173 3
       }
    while ( ret && blank( seq_buff ) );
    return ( ret ? 1 : 0 );
d176 1
d184 1
@


3.3
log
@Added an indent argument to print_seq to improve html appearance.
Added a load_header() routine to strip off > and ; lines that preceed
a sequence in a BNL-FASTA format file.
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.2 1996/10/07 19:04:10 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.2 1996/10/07 19:04:10 mccorkle Exp mccorkle $";
a52 3
#ifdef DEBUG
    printf( "Here 1\n" );
#endif
a55 3
#ifdef DEBUG
        printf( "zob\n" );
#endif
a56 4
          { 
#ifdef DEBUG
            printf( "%d: yob [%s]\n", n, seq_buff );
#endif
a57 1
	  }
a59 3
#ifdef DEBUG
    printf( "Here 2\n" );
#endif
d62 1
a62 6
    while ( n > 0 )
       {
        n--;
#ifdef DEBUG
        printf( "assignment: %d\n", n );
#endif
a63 1
       }
d66 10
@


3.2
log
@Added line-mode input buffering to load_seq() and now load_seq()
will skip lines beginning with '>' and ';' in any input streams.
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.1 1996/09/20 03:22:17 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.1 1996/09/20 03:22:17 mccorkle Exp mccorkle $";
a21 1

d23 1
d27 1
d29 58
a108 1
    reset_input();
a131 2
char   seq_buff[MAX_LINE_LENGTH];
char  *next_seq_char;
d134 1
a134 1
/* reset_input() simply resets the input buffer for the load_seq input by */
d139 1
a139 1
void  reset_input( void )
d144 1
d156 12
d169 2
a170 2
/* get_seq_buff() - read another line into the seq_buff.  If the first       */
/* char is '>' or ';' then read again.  Return 1 if theres data, 0 otherwise */
d174 1
d181 5
d189 2
d198 1
a198 1
    while ( ret && ( seq_buff[0] == '>' || seq_buff[0] == ';' ) );
d202 1
d204 5
a208 1
void print_seq( FILE *output, char *seq, int start, int stop )
d210 2
d220 1
d222 2
d226 1
a226 1
        putchar( seq[i] );
d228 4
a231 1
            putchar( '\n' );
d233 1
a233 1
            putchar( ' ' );
d236 7
a242 1
        putchar( '\n' );
@


3.1
log
@Cosmetic comment change.
@
text
@d6 1
a6 1
/* $Id: io.c,v 3.0 1996/09/17 17:57:36 mccorkle Exp mccorkle $ */
d11 1
a11 1
      "$Id: io.c,v 3.0 1996/09/17 17:57:36 mccorkle Exp mccorkle $";
d23 4
a26 1
void make_char_set_index( char *str, char *char_set );
a27 1

d35 4
a38 4
int load_seq( FILE *input,    /* input; input stream to get chars from */
              char *allowed,  /* input; string of legal chars for seq "acgt"*/
              char *ignored,  /* input; string of chars to ignore "\n\t" */ 
              char *seq       /* output; where to place output sequence */
d50 2
a51 1
    while ( seq < seq_end && (*seq = getc(input)) != EOF )
d64 1
a64 1
    *(seq-1) = '\0';
d71 52
@


3.0
log
@Upgraded entire database.  Merged plates and tubes into same tables.
Added handling for multiple projects.
This file not changed.
@
text
@d3 1
a3 1
/* Lanuage:      C                                                   */
d6 1
a6 1
/* $Id$ */
d11 1
a11 1
      "$Id$";
@
