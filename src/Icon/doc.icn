# Module:       io.icn
# Programmer:   Sean R. McCorkle
# Language:     Icon
# Description:  my attempt to embed man-page documentation IN the software
#               such that reasonable text, man-format and html-format data
#               can be generated right from the program
#
# Usage:        link doc
#
#               write_doc( mode, doc_string )
#
#               where  
#                   mode is one of 
#                     "text"  (for normal text output)
#                     "man"   for output into nroff -man to get unix man page
#                     "html"  for html formatted output
#
#               and doc_string is a single string (including newlines) of the
#               output document.
#               Lines begining with
#                     __ are section headers (ie. OPTIONS, DESCRIPTION, etc)
#                     _. are list items 
#               Other lines are taken as text.  Text mode output pretty much
#               mimics the actual docstring.  To preserve alignment in text
#               mode, if the first two chars are blanks, then they're stripped 
#               off.
#
#               In the text, constructions like <n> or <str> are converted
#               to boldface n or str for man output, and blue font n and str
#               for html output.
#
# Example:
#
#           write_doc( "man", "\
#__Name      pp - sequence pretty-printer                                     \
#                                                                             \
#__Usage     pp [options] [<seq> [<seq> ... ] ]                               \
#                                                                             \
#            where <seq> is a file that contains one or more fasta format DNA \
#            or amino acid sequences. A single hyphen (-) can be used as      \
#            a file name to specify stdin.  If no files are given,            \
#            stdin is scanned.                                                \
#                                                                             \
#__Options                                                                    \
#_.             -B <n>   begin at position n                                  \
#_.             -L <n>   print <n> characters                                 \
#_.             -h       print help then exit                                 \
#_.             -l <n>   print <n> characters per line (default 50)           \
#_.             -n       don't print position numbers on left                 \
#_.             -s <n>   insert a space every <n> characters (default 10),    \
#                        if 0 or <0, no subgrouping is done                   \
#_.             -t <str> use <str> as header title                            \
#_.             -v       print version then exit                              \
#__Note                                                                       \
#             -B, -L and -t are applied to each sequence (they really         \
#             only make sense for input which is a single sequence            \
#                " )
#
#
# $Id$
#

global doc_html_state

#
# This is the one public routine
#
procedure  write_doc( mode, s )

    local p

    doc_header( mode, "pp", "today", "etc" )
    s ? while p := tab( upto( '\n' ) ) do
	    {
             doc_line( mode, p )
             move( 1 )
	    }
end

#
#  Here begin the private routines - not intended for use outside this
#  module
#

procedure  doc_header( mode, title, date, etc )

    case mode of
       {
        "text":  write( title, " ", date, " ", etc )
        "man":   write( ".TH \"", title, "\" \"", date, "\" \"", etc, "\"" )
        "html":  write( "<title>", title, "</title>\n<blockquote>" )
       }

end

procedure  doc_line( mode, line )

    local title, rest, sp1, sp2

    line ? {
            if tab( match( "__" ) )
              then
                  {
                   title := tab( many( &letters ) )
                   sp1 := tab( many( ' ' ) )
                   rest := tab( 0 )
                   doc_sec_header( mode, title, rest, sp1 ) 
		  }
            else if tab( match( "_." ) )
              then
                  {
                   sp1 := tab( many( ' ' ) )
                   title := tab( upto( ' ' ) )
                   sp2 := tab( many( ' ' ) )
                   if ( match( "<" ) )
                      then {
                            title ||:= " " || tab( upto( ">" ) + 1 )
                            sp2 := tab( many( ' ' ) )
                           }
                   rest := tab( 0 )
                   doc_item( mode, title, rest, sp1, sp2 ) 
		  }
            else if ( pos( 0 ) | ( tab( many( ' ' ) ) & pos( 0 ) ) )
              then
                  doc_par( mode )
              else
                  doc_text( mode, tab( 0 ) )
           }
end


procedure doc_sec_header( mode, title, rest, sp )

    case mode of
       {
        "text":  write( title, sp, rest )
        "man":  {
                 write( ".SH ", map( title, &lcase, &ucase ) )
                 doc_text( mode, rest )
                }
        "html": {
                 clear_html_state()
                 write( "</blockquote>" )
                 write( "<h4>", title, "</h4>\n<blockquote>" )
                 doc_text( mode, rest )
                }
       }
end

procedure doc_item( mode, title, rest, sp1, sp2 )

    local t

    t := doc_process( mode, title )
    case mode of
       {
        "text": write( sp1, title, sp2, rest )
        "man":  {
                 write( ".IP \"", t, "\"" )
                 doc_text( mode, rest )
	        }
        "html": {
                 set_html_state( "item" )
                 write( "<dt><tt>", t, "</tt></dt><dd>" )
                 doc_text( mode, rest )
	        }
       }
end

procedure doc_text( mode, s )
    case mode of
       {
        "man"|"html":   s ? { tab( many( ' ' ) )
                              write( doc_process( mode, tab( 0 ) ) )
                            }
        "text":         s ? { tab( match( "  " ) )
                              write( doc_process( mode, tab( 0 ) ) )
                            }
        default: write( s )
       }
end


#
# Paragraph marker
#
procedure doc_par( mode )
    case mode of
       {
        "html":  { clear_html_state(); write( "<P>" ) }
        "man":   write( ".PP" )
        "text":  write( " " )
       }
end

#
# Convert <n> type constructions to fancy fonts if not text output
# this is probably better written with regexps

procedure doc_process( mode, s )

    local t, a

    if ( mode == "text" )
      then return( s )

    s ? { 
         t := ""
         while a := tab( upto( '<' ) ) do
	    {
             t ||:= a
             move( 1 )
             if any( &letters )
               then {
                     if  b := tab( upto( '<>' ) )
                       then {
                              if  match( ">" )
                                then
                                   t ||:= doc_trans( mode, b )
                                else
                                   t ||:= "<" || b || ">"
                              move( 1 )
		            }
                       else
                             t ||:= "<" || tab( 0 )
                    }
               else 
                     t ||:= "<"
	    }
         return( t || tab( 0 ))
        }
end

procedure  doc_trans( mode, s )
   case mode of
      {
       "html":  return( "<font color=\"blue\">" || s || "</font>" )
       "man":   return( "\\fI" || s || "\\fR" )
       default: return( s )
      }
end

procedure  set_html_state( state )

    if doc_html_state == state
      then return
    if ( doc_html_state == "" & state == "item" )
      then write( "<DL>" )
      else stop( "wierd html state!\n" )
    doc_html_state := state

end

procedure  clear_html_state()

    if \doc_html_state == "item"
       then write( "</DL>" )
    doc_html_state := ""
    
end

