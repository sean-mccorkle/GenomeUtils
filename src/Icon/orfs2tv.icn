# Program:      orfs2tv
# Programmer:   Sean R. McCorkle
# Language:     Icon
# Description:  Reads concatenated ORF fasta-format dna sequence files output 
#               from either orfs or tras (i.e. tras -d files ) and converts 
#               them to graphics instructions for drawing horizontal lines
#               for the view program.
#               
#               Output from "orfs" & Ping's "tras" program is tranlated into 
#               h_line instructions for "view"  program.
#
# Usage:        orfs2tv [-dhv] [-t <t>] [-y <y>] [<file> ...]
#
#               a single hyphen (-) can be used as a file name to specify
#               stdin.  If no files are specified, stdin is scanned.
#
# Options:
#               -d      generate lpress display actions to identify orf
#               -h      print help
#               -v      print version
#               -t <t>  make horizontal bars <t> pixels thick (real)
#               -y <y>  place horizontal bars at position <y> in tiers (real)
#
# $Id: orfs2tv.icn,v 0.6 2000/03/24 15:48:36 mccorkle Exp mccorkle $
#

link    io
link    math
link    options

record  header( a, b, f, strt )

global  color_table
global  tier_base

                             ################
                             # Main Program #
                             ################


procedure  main( args )

    local infile, line, y, thick, maxpos, lbnd, tier

    initialize()
    maxpos := 0

    opts := options( args, "-h -v -d -t. -y.", opt_err )
    if member( opts, "h" )  then { help(); exit() }
    if member( opts, "v" )  then { version(); exit() }
    if member( opts, "t" )
        then { thick := opts["t"]; lbnd := (1.0*thick) / 2.0; }
        else { thick := 0.0; lbnd := 0.1 }
    y := ( \opts["y"] | 0.5 )

    if ( *args = 0 ) then push( args, "-" )   # use stdin if no filenames

    write( "# View graphics instructions, generated by tras2map" )
    write( "# " )

    every infile := open_f( !args ) do
       {
        while ( line := read( infile ) ) do
            if ( line ? match( ">" )  )
              then 
               {
                ( line ? h := (orfs_header() | tras_header()) ) |
                     stop( "bad header line " ||  line )
                if ( h.a > maxpos ) then maxpos := h.a
                if ( h.b > maxpos ) then maxpos := h.b
                if ( h.f > 0 ) 
                  then  tier := h.f + tier_base
                  else  tier := h.f - tier_base
                if ( thick > 0.0 )
                  then
                    write( "t_rect ", tier, " ", h.a, " ", h.b, " ", 
                            y - lbnd, " ", y + lbnd, " ",
                            color_table[ h.strt ], " # ", h.strt  )
                  else
                    write( "t_hline ", tier, " ", h.a, " ", h.b, " ", y, " ",
                            color_table[ h.strt ], " # ", h.strt  )
                if member( opts, "d" )
                    then write( "lpress ", tier, " ", h.a, " ", h.b, " ",
                                 y - lbnd, " ", y + lbnd,
                                 " display \"", line, "\"" ) 
	       }
        close( infile )
       }
    #
    # t_hline commands are first buffered by view.  The next three are
    # process as they are encountered (or ignored if already sent), so
    # this is a perfectly good way to work
    #

end

procedure open_f( filename )

    local infile

    write( "#### ", filename )
    if filename == "-"
      then infile := &input
      else ( infile := open( filename )  | stop( "can't open ", filename ) )
    return( infile )

end


procedure initialize()

   tier_base := 1
   color_table := table( "black" )
   color_table[ "TAA" ] := "purple"
   color_table[ "TAG" ] := "grey"
   color_table[ "TGA" ] := "red"
   color_table[ "ATG" ] := "green"
   color_table[ "GTG" ] := "orange"

   color_table[ "TTG" ] := "blue"   # wierd starts for  t7, etc

end

procedure orfs_header()

    local dir, f, pos, length, strt

    ( tab( match( ">" ) )  &
              ( dir := tab( any( "RF" ) ) ) &
              f := tab( any( "123" ) ) &
              tab( match( "-" ) ) &
              ( pos := tab( many( &digits ) ) ) &
              tab( match( "-" ) ) &
              ( length := tab( many( &digits ) ) ) &
              tab( match( "-" ) ) &
              ( strt := tab( many( "ACGT" ) ) ) &
              (
                ( ( (dir == "R") & ( f := -f )) | ( f := f ) ) &
                return( header( pos, pos + length, f, strt ) )
               ) )
          | fail
              
           
end

procedure tras_header()

    local a, b, f, strt

      (  tab( match( ">" ) ) &
                 ( a := tab( many( &digits ) ) ) &
                 tab( match( "-" ) ) &
                 ( b := tab( many( &digits ) ) ) &
                 tab( match( "-" ) ) &
                 ( f := tab( any( "123" ) ) ) &
                 ( ( tab( match( "R" ) ) & (f := -f) ) | f := f ) &
                 tab( match( "-" ) ) &
                 ( strt := tab( many( "ACGT" ) ) ) &
                 return( header( a, b, f, strt ) ) )
         | fail 
           
end


#
# print version number & help
#

procedure help()

    version()
    write( "Usage:  orfs2tv [options] [<file> ...]\n" )
    write( "        a single hyphen (-) can be used as a file name to specify")
    write( "        stdin.  If no files are specified, stdin is scanned.\n" )
    write( "Options:" )
    write( "        -d      generate lpress display actions to identify orf" )
    write( "        -h      print help" )
    write( "        -v      print version" )
    write( "        -t <t>  make horizontal bars <t> pixels thick (real)" )
    write( "        -y <y>  place horizontal bars at position <y> in tiers",
                    " (real)" )

end

#
# print version number
#
procedure version()

    "$Revision: 0.6 $" ? { tab( upto( ' ' ) )
                           write( "orfs2tv", tab( many( &digits ++ ' .' ) ) )
		         }
end

#
# slightly more informative option error message
#
procedure opt_err( msg )

   write( &errout, "orfs2tv: ", msg, "  (type orfs2tv -h for help)" )
   exit( 1 )

end


