head	0.7;
access;
symbols;
locks
	mccorkle:0.7; strict;
comment	@# @;


0.7
date	2000.03.24.15.39.29;	author mccorkle;	state Exp;
branches;
next	0.6;

0.6
date	2000.02.25.20.36.45;	author mccorkle;	state Exp;
branches;
next	0.5;

0.5
date	2000.01.19.02.52.49;	author mccorkle;	state Exp;
branches;
next	0.4;

0.4
date	99.12.15.15.39.45;	author mccorkle;	state Exp;
branches;
next	0.3;

0.3
date	99.11.20.01.47.50;	author mccorkle;	state Exp;
branches;
next	0.2;

0.2
date	99.10.20.00.29.09;	author mccorkle;	state Exp;
branches;
next	0.1;

0.1
date	99.10.18.15.05.42;	author mccorkle;	state Exp;
branches;
next	;


desc
@ORF finder program.
@


0.7
log
@fixed small > to >= problem with orf_length_thresh, and cleaned up
handling of opts["m"]
@
text
@# Program:      orfs
# Programmer:   Sean R. McCorkle
# Language:     Icon
# Description:  Reads a sequence file (fasta format), finds all Open Reading
#               Frames (ORFs) in all, and writes them out.
#
#               The DNA sequences of the ORFs are written out in FASTA
#               format, and each orf header is in the format:
#
#               >R-P-L-B-E
#
#               where:
#
#                   R is one of the 6 reading frames:
#
#                      F1, F2, F3 - forward direction (top strand), starting
#                                   at the 1st, 2nd or third position from
#                                   left end
#                      R1, R2, R3 - reverse direction (bottom strand), starting
#                                   at the 1st, 2nd or third position from 
#                                   right end
#
#                   P is the position of the leftmost end of the ORF,
#                     regardless of reading direction.  Leftmost position in
#                     the sequence is 1).
#
#                   L is the length of the ORF, in nucleotides
#
#                   B is the start (beginning) codon (ATG, GTG)
#
#                   E is the stop (ending) signal (non-coding), ie. TAG, TAG, 
#                     etc.
#
#               The DNA sequence of each ORF follows its header.  The sequence
#               includes the start codon, but excludes the stop codon.
#
#               ORFs are output in order of postion, by each reading frame.
#
# Usage:        orfs [-hv] [-m <n>] <seq file>
#
#               where <seq file> contains a single DNA sequence (fasta).
#               If not specified, stdin is used.
#
# Options:
#
#              -a       append sequence title to orf headings ( |title)
#              -h       print help, then exit
#              -m <n>   set minimum length threshold to <n> bases (default 300)
#              -s       don't print the ORF sequences, just the header
#              -v       print version, then exit
#
# $Id: orfs.icn,v 0.6 2000/02/25 20:36:45 mccorkle Exp mccorkle $
#

link    io
link    options

global  bases
global  starts
global  stops
global  triplets
global  codons
global  nonstarts
global  freq_table

global  orf_length_thresh


            
procedure main( args )

    local infile, s, signal, opts

    opts := options( args, "-a -h -m+ -s -v", opt_err )
    if member( opts, "h" )  then { help(); exit() }
    if member( opts, "v" )  then { version(); exit() }

    infile := open_file( (*args > 0 & args[1]) | "-" )
 
    init_globals( opts )

    fseq := read_fasta( infile )
    s := table()
    s["F"] := map( fseq.seq, &lcase, &ucase )
    s["R"] := rc( s["F"] )
    write( "; ORFs, sequence: ", fseq.heading, " length: ", *s["F"] );

    find_orfs( s, opts, fseq.heading )

end

#
#  process options which set globals and built the various triplet sets
#
procedure  init_globals( opts )

    orf_length_thresh := ( \opts["m"] | 300 )

    bases  := set( ["A", "C", "G", "T", "N", "M", "R", "W", "S", "Y", "K",
                    "V", "H", "D", "B" ] )
    starts := set( [ "ATG", "GTG", "TTG" ] )
    stops  := set( [ "TAA", "TGA", "TAG" ] ) 
    triplets := set()
    every insert( triplets, !bases || !bases || !bases )
    codons := triplets -- stops    
    nonstarts := triplets -- starts


end


procedure find_orfs( s, opts, seqname )

    local dir, f, a, orf

    every dir := ( "F" | "R" ) do
        every f := 1 to 3 do
           {
            s[dir] ? {
                       move( f - 1 )   # shift to this frame
                       orf := "z"
                       while ( orf ~== "" ) do
               	          {
                           while member( nonstarts, move( 3 ) ) # to next start
                           a := &pos
                           while  member( codons, move( 3 ) )   # to next stop
                           orf := &subject[a:&pos]
                           ending := move( 3 ) | ""
                           if ( orf ~== "" & ending ~== "" & 
                                *orf >= orf_length_thresh )
                             then
                               { 
                                if ( dir == "R" )               # convert to
                                   then a := *s[dir] + 5 - &pos # leftmost end
                                write_fasta( &output, 
                                             if member( opts, "s" ) 
                                                 then "" else orf, 
                                             dir || f || "-" || a || "-" ||
                                             *orf || "-" ||  orf[1+:3] ||
                                             "-" || ending ||
                                             if member( opts, "a" )
                                                 then ( "|" || seqname )
                                                 else ""
                                             )
                                                 
			       }
        		  }
           	     }
           }

end




#
# print version number & help
#

procedure help()

    version()
    write( "\nUsage:  orfs [-hv] [-m <n>] <seq file>\n" )
    write( "        a single hyphen (-) can be used as a file name to specify")
    write( "        stdin.  If no files are specified, stdin is scanned.\n" )
    write( "Options:" )
    write( "        -a       append sequence title to orf headings ( |title)" )
    write( "        -h       print help" )
    write( "        -m <n>   set minimum length threshold to <n> bases ",
                             "(default 300)" )
    write( "        -s       don't print the ORF sequences, just the header" )
    write( "        -v       print version" )

end

#
# print version number
#
procedure version()

    "$Revision: 0.6 $" ? { tab( upto( ' ' ) )
                           write( "orfs", tab( many( &digits ++ ' .' ) ),
                                  " Find Open Reading Frames"
                                )
		         }
end

#
# slightly more informative option error message
#
procedure opt_err( msg )

   write( &errout, "orfs: ", msg, "  (type orfs -h for help)" )
   exit( 1 )
end


@


0.6
log
@added -a option, to append sequence title to orf headings.
@
text
@d52 1
a52 1
# $Id: orfs.icn,v 0.5 2000/01/19 02:52:49 mccorkle Exp mccorkle $
d97 1
a97 2
    orf_length_thresh := 300
    if member( opts, "m" )  then orf_length_thresh := opts["m"]
d130 1
a130 1
                                *orf > orf_length_thresh )
d181 1
a181 1
    "$Revision: 0.5 $" ? { tab( upto( ' ' ) )
@


0.5
log
@Added handling for all the DNA ambiguity codes
Cleared up a bug with the lower case in reverse complement.
@
text
@d46 1
d52 1
a52 1
# $Id: orfs.icn,v 0.4 1999/12/15 15:39:45 mccorkle Exp mccorkle $
d74 1
a74 1
    opts := options( args, "-h -m+ -s -v", opt_err )
d88 1
a88 1
    find_orfs( s, opts )
d113 1
a113 1
procedure find_orfs( s, opts )
d141 5
a145 1
                                             "-" || ending )
d168 1
d182 1
a182 1
    "$Revision: 0.4 $" ? { tab( upto( ' ' ) )
@


0.4
log
@reworked the codon/signal identification to use move(3) and set membership
rather than generators - the speed increase is enormous.
@
text
@d51 1
a51 1
# $Id: orfs.icn,v 0.3 1999/11/20 01:47:50 mccorkle Exp mccorkle $
d83 2
a84 2
    s["F"] := fseq.seq
    s["R"] := rc( fseq.seq )
d99 2
a100 1
    bases  := set( ["A", "C", "G", "T", "N" ] )
d176 1
a176 1
    "$Revision: 0.3 $" ? { tab( upto( ' ' ) )
@


0.3
log
@Added option handling, -h, -v, -m and -s options.
@
text
@d23 3
a25 3
#                   P is the position of the leftmost end of the ORF 
#                     (regardless of reading direction).  Leftmost position in
#                     the sequence is 1.
d27 1
a27 1
#                   L is the length of the ORF, in 
d51 1
a51 1
# $Id: orfs.icn,v 0.2 1999/10/20 00:29:09 mccorkle Exp mccorkle $
d91 3
d96 3
a106 2
    orf_length_thresh := 300
    if member( opts, "m" )  then orf_length_thresh := opts["m"]
d113 1
a113 1
    local dir, f, a, b, orf
d121 1
a121 1
                       while (orf ~== "" ) do
d123 1
a123 1
                           while( tab( match( !nonstarts ) ) )
d125 3
a127 4
                           orf := ending := ""
                           while ( orf ||:= tab( match( !codons ) ) ) 
                           b := &pos
                           ending := move( 3 )
d132 2
a133 2
                                if ( dir == "R" )             # convert to
                                   then a := *s[dir] + 2 - b  # leftmost end
d149 2
d175 1
a175 1
    "$Revision: 0.2 $" ? { tab( upto( ' ' ) )
@


0.2
log
@Added TTG starts, and better handling for filter mode (no command line
argument causes stdio to be read).
@
text
@d39 1
a39 1
# Usage:        orfs <seq file>
d44 8
a51 1
# $Id: orfs.icn,v 0.1 1999/10/18 15:05:42 mccorkle Exp mccorkle $
d54 2
a55 1
link  io
d57 7
a63 7
global bases
global starts
global stops
global triplets
global codons
global nonstarts
global freq_table
d65 1
a65 1
global orf_length_thresh
d71 5
a75 1
    local infile, s, signal
d79 1
a79 3
    init_globals()

    orf_length_thresh := 300
d87 1
a87 1
    find_orfs( s )
d91 1
a91 1
procedure  init_globals()
d101 3
d107 1
a107 1
procedure find_orfs( s )
d131 3
a133 1
                                write_fasta( &output, orf, 
d146 39
@


0.1
log
@Just extracted this as a signle "operator" from scanseq.
@
text
@d44 1
a44 1
# $Id$
d65 1
a65 1
    infile := open_file( args[1] )
d84 1
a84 1
    starts := set( [ "ATG", "GTG" ] )
@
