head	0.16;
access;
symbols;
locks
	mccorkle:0.16; strict;
comment	@# @;


0.16
date	2004.09.19.23.58.33;	author mccorkle;	state Exp;
branches;
next	0.15;

0.15
date	2003.06.21.17.16.59;	author mccorkle;	state Exp;
branches;
next	0.14;

0.14
date	2003.06.21.15.24.17;	author mccorkle;	state Exp;
branches;
next	0.13;

0.13
date	2003.05.06.19.57.05;	author mccorkle;	state Exp;
branches;
next	0.12;

0.12
date	2003.01.09.20.47.02;	author mccorkle;	state Exp;
branches;
next	0.11;

0.11
date	2000.05.08.11.44.37;	author mccorkle;	state Exp;
branches;
next	0.10;

0.10
date	2000.04.26.15.41.26;	author mccorkle;	state Exp;
branches;
next	0.9;

0.9
date	2000.03.08.16.20.36;	author mccorkle;	state Exp;
branches;
next	0.8;

0.8
date	2000.02.28.21.58.57;	author mccorkle;	state Exp;
branches;
next	0.7;

0.7
date	2000.01.19.02.54.21;	author mccorkle;	state Exp;
branches;
next	0.6;

0.6
date	2000.01.18.18.33.50;	author mccorkle;	state Exp;
branches;
next	0.5;

0.5
date	99.12.15.15.25.09;	author mccorkle;	state Exp;
branches;
next	0.4;

0.4
date	99.11.06.04.32.22;	author mccorkle;	state Exp;
branches;
next	0.3;

0.3
date	99.10.12.20.22.39;	author mccorkle;	state Exp;
branches;
next	0.2;

0.2
date	99.10.10.20.23.58;	author mccorkle;	state Exp;
branches;
next	0.1;

0.1
date	99.10.04.20.45.32;	author mccorkle;	state Exp;
branches;
next	;


desc
@Graphics library for sequence graphical displays (viewscan, etc)
@


0.16
log
@added map_y_tier_text() to correctly handle symmetric/asymmetrix
label y positions.
@
text
@# Module:      graf.icn
# Programmer:  Sean R. McCorkle
# Language:    Icon
# Description: System for making sequence feature map plots, showing various
#              features, in different frames, and different colors.
#
#              a sequence map has a horizontal scale in the middle 
#              (representing position in the sequence) and a number of
#              "tiers" above and below the scale.  Tier spacing and height
#              are specifiable, and features are drawn within tiers, with
#              x position given by scale, and y position given in pixels,
#              relative to tier height.  Tier number is an argument - postive
#              is above the scale, negative is below the scale.
#
# Routines:
#              open_window( w, h )  # width and height (pixels) of X11 window
#
#              set_tiers( n_above, n_below, height, spacing ) 
#
#              set_scale( a, b ) # a - sequence positions of left & right end
#
#              draw_scale( color )
#
# $Id: graf.icn,v 0.15 2003/06/21 17:16:59 mccorkle Exp mccorkle $
#
link graphics                       # need icon graphics lib (of course)
link math                           # for floor(x)


global window_width, window_height
global left_margin, right_margin, y_margin # for neatness;margins arnd the edge
global x_min, x_max                 # min and max seq position
global a_x, b_x                     # scales bp to x pixels
global a_y, b_y                     # converts to positive y at 1/2 down
global zero_y                       # pixel coord of y=0 (bottom of scale)
global scale_height                 # scale height in pixels
global scale_length                 # scale length in bp
global ticlen, subticlen            # tic & subtic mark height in pixels
global delta_tics, delta_subtics
global num_tiers_above, num_tiers_below
global tier_height, tier_spacing
global symmetric                    # flag 1 or 0
global fg_color
global bg_color
global window_title

global font_height

#
# open_window( w, h ) 
# open_window( w, h, opts ) -- start the session with one call to this.
# w, h: actual X11 window width and height in pixels
#
#  opts - optional table of values to override parameters which MUST be
#         specified at window creation:
#            defaults
#               opts["bg_color"] = "black"
#               opts["fg_color"] = "white"
#               opts["title"]    = "_"
#
procedure  open_window( w, h, opt_args[] )

    local title, opts

    window_width := w
    window_height := h
    title := ""
    title := opt_args[1]
    if  *opt_args > 0 
      then {
            opts := opt_args[1]
            (type(opts) == "table") | 
                 stop( "open_window options are not a table" )
   	   }
      else  opts := table()
    
    fg_color := ( \opts["fg_color"] | "white" )
    bg_color := ( \opts["bg_color"] | "black" )
    title := ( \opts["title"] | "_" )

    left_margin := 20
    right_margin := 20
    y_margin := 20
    scale_height := 3
    ticlen := 8
    subticlen := 4
    symmetric := 1
    Window( "size=" || window_width || "," || window_height, 
            "bg=" || bg_color, "fg=" || fg_color, "label="||title )
    font_height := WAttrib( "fheight" )

end

procedure set_horiz_margins( left, right )
    right_margin := right
    left_margin := left
end

#
# set_scale( a, b ) - sets horizontal scale.
#
# a, b are min and max sequence positions (bp) to display
#                     
#
procedure  set_scale( a, b )

    local linfo, l

    l := b - a
    linfo := figure_label_info( l )
    delta_tics := linfo[1]
    delta_subtics := linfo[2]

    x_min := floor( (1.0 * a) / (1.0 * delta_subtics) ) * delta_subtics
    x_max := ceil( (1.0 * b) / (1.0 * delta_subtics) ) * delta_subtics
    a_x := (1.0 * ( window_width - (left_margin + right_margin) ) )/
            (1.0 *(x_max - x_min))
    b_x := left_margin - a_x * x_min

    scale_length := x_max - x_min

end

#
# Should fine tune this and make it formulaic
#
procedure figure_label_info( len )

    if      len <= 1000 
        then  return( [100, 20] )
    else if len <= 5000
        then  return( [500, 100] )
    else if len <= 10000
        then  return( [1000, 200] )
    else if len <= 50000
        then  return( [5000, 1000] )
    else if len <= 100000
        then  return( [10000, 2000] )
    else if len <= 500000
        then  return( [50000, 10000] )
    else 
              return( [100000, 20000] )

end

#
#  height is height of scale bar (pixels)
#  scale_color is color of scale

procedure  draw_scale( scale_color  )

    #
    # save fill color here first!
    #
    Fg( scale_color )
    fill_rectangle( x_min, 0, x_max, scale_height )

    FillRectangle( map_x( x_min ), zero_y, scale_length * a_x, -scale_height )
    Fg( fg_color )

    every draw_tic_mark( (x_min to x_max by delta_tics), ticlen )
    every draw_tic_mark( (x_min to x_max by delta_subtics), subticlen )

    every draw_tic_label( (x_min to x_max by delta_tics) )
        
end


procedure draw_tic_mark( p, l )

    DrawLine( map_x( p ), map_y( 0 ), map_x( p ), map_y( -l ) )

end

procedure draw_tic_label( p )

    local n
    n := string( p )
    DrawString( map_x( p ) - TextWidth( n ) / 2, 
                map_y( -ticlen ) + font_height, 
                n )

end

#
# Now this determines the absolute y mapping, so this MUST be invoked before
# anything is drawn, but after open window!
#
procedure set_tiers( n_above, n_below, height, spacing )

    tier_height := height
    tier_spacing := spacing
    num_tiers_above := n_above
    num_tiers_below := n_below

    a_y := (2.0 * y_margin - window_height ) / window_height
    #b_y := y_margin - a_y * window_height / 2.0
    b_y := (window_height - y_margin) -  num_tiers_below *
                     (tier_height + tier_spacing)
    zero_y := map_y( 0 )

end

procedure set_symmetric()
    symmetric := 1
end

procedure set_asymmetric()
    symmetric := 0
end


                         #########################
                         # Tier drawing routines #
                         #########################

# 
# Vertical positions within  a tier are given from the bottom edge up,
# regardless of whether or not the tier number is negative
#
# tier: tier number
# pos: sequence position
# y1, y2 - coordinates in the tier. full scale is 0.0 (bottom) to 1.0 (top)
# color
# Make color an option, and save & restore color

procedure tier_line_vert( tier, pos, y1, y2, color )

    # Make color an option, and save & restore color
    # handle negative tier heights

    local xp
    if ( pos > x_max | pos < x_min )
        then return
    xp := map_x( pos )
    Fg( color )
    DrawLine( xp, map_y_tier( tier, y1 ), xp, map_y_tier( tier, y2 ) )
    
end

#
# y is specified in tier height- 0.0 (bottom of bar) to 1.0 (top),
# regardless of whether the tier is above or below the scale.
#
procedure tier_line_horiz( tier, a, b, y, color )

    local xp1, xp2, yp

    if a > b 
       then a :=: b
    # Now b is maximum of the two
    if ( b < x_min | a > x_max )
        then return
    if ( a < x_min )
        then a := x_min
    if ( b > x_max )
        then b := x_max
    yp := map_y_tier( tier, y )
    xp1 := map_x( a )
    xp2 := map_x( b )
    Fg( color )
    DrawLine( xp1, yp, xp2, yp )   
    
end


procedure tier_line( tier, x1, y1, x2, y2, color )

    local dx, m

    # Make color an option, and save & restore color
    # handle negative tier heights

    if x1 > x2
       then { x1 :=: x2; y1 :=: y2 }
    # Now (x1,y1) has the minimum x of the two points

    if ( x2 < x_min | x1 > x_max )   # trivial case - don't plot at all
       then return

    dx := x2 - x1
    if ( dx > 0 )           # dx is not negative
      then {
             m := ( y2 - y1 ) / dx
             if ( x1 < x_min )
               then {
                     y1 +:= ( x_min - x1 ) * m
                     x1 := x_min
                    }
             if ( x2 > x_max )
               then {
                     y2 -:= ( x2 - x_max ) * m
                     x2 := x_max
                    }
           }

    Fg( color )
    DrawLine( map_x( x1 ), map_y_tier( tier, y1 ), 
              map_x( x2 ), map_y_tier( tier, y2 ) )
    
end


#
# y1, y2 is specified in tier height- 0.0 (bottom of bar) to 1.0 (top),
# regardless of whether the tier is above or below the scale.
#
procedure tier_rect( tier, a, b, y1, y2, color )

    local xp1, xp2, yp1, yp2

    if a > b 
       then a :=: b
    # Now b is maximum of the two
    if ( b < x_min | a > x_max )
        then return
    if ( a < x_min )
        then a := x_min
    if ( b > x_max )
        then b := x_max

    yp1 := map_y_tier( tier, y1 )
    yp2 := map_y_tier( tier, y2 )
    if ( abs(yp2-yp1) < 1 )        # make sure at least 1 pixel shows up for
        then yp2 := yp1 + 1;       # the small stuff

    xp1 := map_x( a )
    xp2 := map_x( b )
    if ( abs(xp2-xp1) < 1 )
        then xp2 := xp1 + 1;
    Fg( color )
    FillRectangle( xp1, yp1, xp2-xp1, yp2-yp1 )

end

#
# y1, y2, y3 is specified in tier height- 0.0 (bottom of bar) to 1.0 (top),
# regardless of whether the tier is above or below the scale.  y3 is the
# height of the point
#
procedure tier_triang( tier, a, b, y1, y2, y3, color )

    local xp1, xp2, yp1, yp2, yp3, rev

    if a > b 
       then { a :=: b
              rev := 1 }
       else 
              rev := 0

      
    # Now b is maximum of the two
    if ( b < x_min | a > x_max )
        then return
    if ( a < x_min )
        then a := x_min
    if ( b > x_max )
        then b := x_max

    if rev = 1
       then a :=: b

    yp1 := map_y_tier( tier, y1 )
    yp2 := map_y_tier( tier, y2 )
    yp3 := map_y_tier( tier, y3 )
    if ( abs(yp2-yp1) < 1 )        # make sure at least 1 pixel shows up for
        then yp2 := yp1 + 1;       # the small stuff

    xp1 := map_x( a )
    xp2 := map_x( b )
    if ( abs(xp2-xp1) < 1 )
        then xp2 := xp1 + 1;
    Fg( color )
    FillPolygon( xp1, yp1, xp1, yp2, xp2, yp3 )

end


procedure tier_varrow( tier, pos, y1, y2, color )

    # Make color an option, and save & restore color
    # handle negative tier heights

    local xp, yp1, yp2, ypm, w

    w := 4;
    if ( pos > x_max | pos < x_min )
        then return
    xp := map_x( pos )
    yp1 := map_y_tier( tier, y1 ) 
    yp2 := map_y_tier( tier, y2 ) 
    ypm := map_y_tier( tier, (y1 + y2) / 2.0 ) 
    Fg( color )
    DrawLine( xp, yp1, xp, yp2 )
    FillPolygon( xp - w, ypm, xp, yp2, xp + w, ypm )

end

procedure tier_text( tier, x, y, str, color )

    Fg( color )
    DrawString( map_x( x ), map_y_tier_text( tier, y ), str )
    
end

procedure tier_llabel( tier, y, str, color )

    Fg( color )
    DrawString( 10, map_y_tier_text( tier, y ), str )
    
end

procedure tier_rlabel( tier, y, str, color )

    Fg( color )
    DrawString( window_width + 5 - right_margin, 
                map_y_tier_text( tier, y ), str )
    
end

#
# This is not truncating diagonal lines properly!!!
#
procedure cross_tier_line( tier1, x1, y1, tier2, x2, y2, color )

    local dxp, xp1, yp1, xp2, yp2, xminp, xmaxp, mp

    if x1 > x2
       then { x1 :=: x2; y1 :=: y2; tier1 :=: tier2 }
    # Now (x1,y1) has the minimum x of the two points

    if ( x2 < x_min | x1 > x_max )
        then return                     # trivial case - don't plot at all

    xp1 := map_x ( x1 )
    yp1 := map_y_tier( tier1, y1 )
    xp2 := map_x ( x2 )
    yp2 := map_y_tier( tier2, y2 )
    xminp := x_min                        # should be maintained as a global
    xmaxp := x_max                        # should be maintained as a global

    dxp := xp2 - xp1
    if ( dxp > 0 )           # dx is not negative
      then {
             mp := ( yp2 - yp1 ) / dxp
             if ( xp1 < xminp )
               then {
                     yp1 +:= ( xminp - xp1 ) * mp
                     xp1 := xminp
                    }
             if ( xp2 > xmaxp )
               then {
                     yp2 -:= ( xp2 - xmaxp ) * mp
                     xp2 := maxp
                    }
           }

    Fg( color )
    DrawLine( map_x( x1 ), map_y_tier( tier1, y1 ), 
              map_x( x2 ), map_y_tier( tier2, y2 ) )
    
end


procedure map_y_tier_text( tier, y )

    if ( tier > 0 | symmetric = 0 )
      then return( map_y_tier( tier, y ) )
      else return( map_y_tier( tier, 1.0 - y ) )
end

#
# takes tier number (integer) and y [0.0 - 1.0] and returns correct
# pixel position for y
#
# Note: this assumes tier=0 is never invoked.
#
procedure map_y_tier( tier, y )

    local yp

    if ( tier > 0 )
      then
        return( b_y + y * a_y * tier_height -
                ( ( tier - 1 ) * ( tier_spacing + tier_height ) + 
                tier_spacing + scale_height ) )

    # Here, we handle below the scale (tier is negative)

    if ( symmetric = 1 ) 
       then yp := -y * a_y * tier_height
       else yp := -(1.0 - y) * a_y * tier_height

    return(  b_y - (( tier + 1 ) * ( tier_spacing + tier_height ) -
             ( tier_spacing + ticlen + yp ))
          )

end


#
# low level drawing routines - not for public use!
#

procedure fill_rectangle( x1, y1, x2, y2 )

   FillRectangle( map_x( x1 ), map_y( y1 ),
                  ( x2-x1 ) * a_x, ( y2 - y1 ) * a_y )

end

procedure  highlight_scale( x, l )

    Fg( "green" )
    FillRectangle( x, zero_y, l, -scale_height )

end


procedure  map_x( x )
   return( a_x * x + b_x )
end

procedure  map_y( y )
   return( a_y * y + b_y )
end

procedure  unmap_x( x )
   return( ( x - b_x ) / a_x )
end

procedure  unmap_y( y )
   return( ( y - b_y ) / a_y )
end





@


0.15
log
@needed to force some conversions on the mac linuxpcc system.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.14 2003/06/21 15:24:17 mccorkle Exp mccorkle $
d402 1
a402 1
    DrawString( map_x( x ), map_y_tier( tier, y ), str )
d409 1
a409 1
    DrawString( 10, map_y_tier( tier, y ), str )
d416 2
a417 1
    DrawString( window_width + 5 - right_margin, map_y_tier( tier, y ), str )
d462 8
@


0.14
log
@ added y position for rlabel and llabel
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.13 2003/05/06 19:57:05 mccorkle Exp mccorkle $
d114 3
a116 3
    x_min := floor( 1.0 * a / delta_subtics ) * delta_subtics
    x_max := ceil( 1.0 * b / delta_subtics ) * delta_subtics
    a_x := ( window_width - (left_margin + right_margin) ) /
@


0.13
log
@added tier_varrow and tier_triang routines for rendering t_varrow and
t_triang dohickeys.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.12 2003/01/09 20:47:02 mccorkle Exp mccorkle $
d406 1
a406 1
procedure tier_llabel( tier, str, color )
d409 1
a409 1
    DrawString( 10, map_y_tier( tier, 0 ), str )
d413 1
a413 1
procedure tier_rlabel( tier, str, color )
d416 1
a416 1
    DrawString( window_width + 5 - right_margin, map_y_tier( tier, 0 ), str )
@


0.12
log
@Fixed it so that teeny little rectanges get at least 1 pixel so they don't
disappear.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.11 2000/05/08 11:44:37 mccorkle Exp mccorkle $
d84 1
a84 1
    scale_height := 6
d159 1
a159 1
    Fg( "white" )
d333 63
@


0.11
log
@split x_margin into left_margin and right_margin.
added tier_llabel() and tier_rlabel() for label writing.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.10 2000/04/26 15:41:26 mccorkle Exp mccorkle $
d324 2
d329 2
d332 2
a333 2
    FillRectangle( xp1, yp1, xp2-xp1, yp2-yp1 )   
    
@


0.10
log
@added options table to "open_window"
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.9 2000/03/08 16:20:36 mccorkle Exp mccorkle $
d31 1
a31 1
global x_margin, y_margin           # for neatness - margins around the edge
d81 2
a82 1
    x_margin := 20
a87 1
    #write( "ay ", a_y, "  b_y  ", b_y )
d94 5
a112 2
    #write( "initial delta_tics", delta_tics )
    #write( "initial delta_subtics", delta_subtics )
d116 3
a118 3
    a_x := ( window_width - 2.0 * x_margin ) / (1.0 *(x_max - x_min))
    b_x := x_margin - a_x * x_min
    #write( "a_x = ", a_x, " b_x = ", b_x )
d334 13
a346 1
    local xp
a347 3
#    if ( pos > x_max | pos < x_min )
#        then return
    xp := map_x( x )
d349 1
a349 1
    DrawString( xp, map_y_tier( tier, y ), str )
@


0.9
log
@added tier_text() subroutine.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.8 2000/02/28 21:58:57 mccorkle Exp mccorkle $
d43 3
d50 2
a51 1
# open_window( w, h ) - start the session with one call to this.
d54 7
d63 2
a64 1
    local title
d69 12
d89 1
a89 1
            "bg=black", "fg=white", "label="||title )
@


0.8
log
@added cross_tier_line() procedure, fixed truncation problem in tier_line()
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.7 2000/01/19 02:54:21 mccorkle Exp mccorkle $
d302 12
@


0.7
log
@expanded handling for larger scales in figure_label_info
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.6 2000/01/18 18:33:50 mccorkle Exp mccorkle $
d240 36
d302 43
@


0.6
log
@temporary hack - moved absolute y-map calculation  to set_tier.
The entire calculation/setting scheme needs to be seriously reworked.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.5 1999/12/15 15:25:09 mccorkle Exp mccorkle $
d97 4
d102 14
a115 1
procedure figure_label_info( len )
a116 9
   if len <= 1000 
    then 
        return( [100, 20] )
    else
        if len <= 5000
        then 
            return( [500, 100] )
        else
            return( [5000, 1000] )
@


0.5
log
@added symmetric and asymmetric y-coordinate system handling for tiers..
reworked map_y_tier, added set_symmetric, set_asymmetric
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.4 1999/11/06 04:32:22 mccorkle Exp mccorkle $
a62 2
    a_y := (2.0 * y_margin - h ) / h
    b_y := y_margin - a_y * h / 2.0
a93 1
    zero_y := map_y( 0 )
d150 4
d160 6
@


0.4
log
@added tier_rect() and some fixes.
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.3 1999/10/12 20:22:39 mccorkle Exp mccorkle $
d38 1
a38 1
global ticlen, subticlen
d42 1
a45 1

d62 1
d162 9
d257 3
d262 2
d266 13
a278 5
        return( map_y( tier * ( tier_spacing + tier_height ) + scale_height ) -
                (1.0 - y ) * a_y * tier_height )
      else
        return( map_y( tier * ( tier_spacing + tier_height ) - ticlen ) +
                y * a_y * tier_height )
d296 3
a298 1
   FillRectangle( x, zero_y, l, -scale_height )
d317 1
@


0.3
log
@added height argument to tier_line_horiz().
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.2 1999/10/10 20:23:58 mccorkle Exp mccorkle $
d64 1
a64 1
    write( "ay ", a_y, "  b_y  ", b_y )
d85 2
a86 2
    write( "initial delta_tics", delta_tics )
    write( "initial delta_subtics", delta_subtics )
d92 1
a92 1
    write( "a_x = ", a_x, " b_x = ", b_x )
d180 1
a180 2
    local x, yoff
    Fg( color )
d183 3
a185 10
    x := map_x( pos )
    if ( tier > 0 )
      then
        yoff := scale_height + tier_spacing + ( tier - 1 ) * 
                 ( tier_spacing + tier_height )
      else
        yoff := tier * ( tier_spacing + tier_height ) - ticlen

    DrawLine( x, map_y( yoff + tier_height * y1 ), 
              x, map_y( yoff + tier_height * y2 )   )
d195 28
a222 1
    local x1, x2, yp
d233 6
d240 9
d251 2
a252 2
        yp := map_y( tier * ( tier_spacing + tier_height ) + scale_height ) -
             (1.0 - y ) * a_y * tier_height
d254 3
a256 6
        yp := map_y( tier * ( tier_spacing + tier_height ) - ticlen ) +
             y * a_y * tier_height
    x1 := map_x( a )
    x2 := map_x( b )
    DrawLine( x1, yp, x2, yp )   
    
d259 1
d263 1
d288 5
@


0.2
log
@added title optional argument to open_window()
@
text
@d24 1
a24 1
# $Id: graf.icn,v 0.1 1999/10/04 20:45:32 mccorkle Exp mccorkle $
d197 5
a201 1
procedure tier_line_horiz( tier, a, b, color )
d203 1
a203 1
    local x1, x2, y
d217 2
a218 2
        y := map_y( tier * ( tier_spacing + tier_height ) + scale_height ) -
             0.5 * a_y * tier_height
d220 2
a221 2
        y := map_y( tier * ( tier_spacing + tier_height ) - ticlen ) +
             0.5 * a_y * tier_height
d224 1
a224 1
    DrawLine( x1, y, x2, y )   
@


0.1
log
@We're getting pretty functional, so we'd better check it in.
@
text
@d24 1
a24 1
# $Id$
d50 1
a50 1
procedure  open_window( w, h )
d52 1
d55 2
d66 1
a66 1
            "bg=black", "fg=white" )
@
