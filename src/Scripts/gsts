#!/usr/bin/perl
# Program:       gsts
# Programmer:    Sean R. McCorkle, 
#                Biology Department, Brookhaven National Laboratory
#
# Language:      perl
#
# Description:   Reads genome sequences, prints out table of Genome Sequence
#                Tags (GSTs)
#
# Usage:         gsts [-chvFIV] [-a<seq>] [-e<n>] [-f<seq>] [seq-files ...]
#
#                where [seq-files] are in FASTA format.  stdin is scanned if
#                no file specified.
#
# Options:       -a<seq> use <seq> as anchor enzyme sequence (def. CATG)
#                -c      treat all sequences as circular
#                -e<n>   tag extent <n> (default 17)
#                -f<seq> use <seq> as fragmenting enzyme seq (def. ACTAGT)
#                -h      print help message
#                -l<seq> append linker sequence <seq> to short tags 
#                        (default GGATCCGAAGGGGTTCG)
#                -v      verbose mode
#                -F      print out fragment information, rather than tag
#                -I      print out internal tags as well as true GSTs
#                -S      print out anchor site to 3' fragment end sequences
#                        (fasta format).  Doesn't include linker
#                -V      print version
#
# Caveats:       Sequence characters other than standard nucleotide and
#                ambiguity codes will not be detected and will cause undefined
#                behavior.  GIGO.
#
#                Note to self: consider options for adding fragment offsets to
#                tag positions as well, taglengths, etc.
#
#                (note: sequences are not regular expressions (yet))
#
# $Id: gsts,v 0.9 2012/03/06 21:10:49 seanmccorkle Exp $
#

use  Getopt::Std;



die "bad option\n" unless ( getopts( 'a:ce:f:hl:vFISV' ) );


$anchenz  = $opt_a ? uc( $opt_a ) : 'CATG';  # anchoring enzyme default NlaIII 
#$fragenz  = $opt_f ? uc( $opt_f ) : 'GGATCC'; # frag'ing enzyme default BamHI 
#$fragenz  = $opt_f ? uc( $opt_f ) : 'GCGGCCGC';  # frag'ing enzyme, def. NotI 
$fragenz  = $opt_f ? uc( $opt_f ) : 'ACTAGT';  # frag'ing enzyme, def. SpeI
$linker = $opt_l ? uc( $opt_l ) : 'GGATCCGAAGGGGTTCG';

$tag_ext     = $opt_e ? $opt_e : 17;  # tag extent, default 17 for MmeI
$anchenz_len = length( $anchenz );
$fragenz_len = length( $fragenz );


                              ################
                              # Main program #
                              ################

if ( $opt_h )  { help(); }
if ( $opt_V )  { version(); exit; } 
    

while ( <> )                              # continue reading lines until EOF
   {
    chomp;
    if ( /^>(.*)/ )                       # if its a FASTA header, then
       {                                  # grab it, save the file name
        $new_hdr = $1;                    # and if we've got a previously 
        $file = $ARGV;                    # collected sequence, then
        process( $seq, $hdr, $file ) if ( defined( $hdr ) );  # handle it
        $hdr = $new_hdr;                  # and then reset the buffer
        $seq = "";
       }
    else                                  # otherwise, assume its a sequence
       {                                  # line, so append it to the current
        s/\s//g;                          # buffer
        $seq .= uc( $_ );
        if ( $opt_v )
           { print STDERR "$lineno\n" unless ( ++$lineno % 10000 ); }
       }
   }

#
# don't forget to handle the sequence remaining in the buffer before exiting
#
process( $seq, $hdr, $file ) if ( defined( $hdr ) );  


                               ###############
                               # Subroutines #
                               ###############

#
# process( $seq, $hdr, $file ) - split sequence into fragments, and process
# each fragment seperately.   
#
sub  process
   {
    my ( $seq, $hdr, $file ) = @_;
    my $i, $fstart, $fstop;
    $seqnum++;                               # sequence number counter (global)
   
    print STDERR "[$file] $hdr", length( $seq ),"\n" if ( $opt_v );
    print STDERR "$file ", length( $seq ), "\n" if ( $opt_v );
    
    my @fpos = matches( $fragenz, $seq );
    return unless ( @fpos );
    printf STDERR "%12s %10d\n",  $fragenz, $#fpos + 1, "\n" if ( $opt_v );
    #
    # Handle the interior fragments
    #
    for ( $i = 0; $i < $#fpos; $i++ )
       { 
        $fstart = $fpos[$i] + $fragenz_len;  # exclude the frag enz sequence
        $fstop = $fpos[$i+1];
        process_frag( $i+1, $fstart, "fr",
                      substr( $seq, $fstart, $fstop - $fstart ) ); 
       }

    #
    # If the DNA is circular, make a special fragment by concatenating the ends
    #
    $fstart = $fpos[$#fpos] + $fragenz_len;
    if ( $opt_c )
       { 
        process_frag( $i+1, $fstart, "fr",
                      substr($seq, $fstart) . 
                      substr($seq, 0, $fpos[0]) ); 
       }
    else
       {
        process_frag( 0, 0, "f", substr( $seq, 0, $fpos[0] ) );
        process_frag( $#fpos + 1, $fstart, "r", 
                       substr( $seq, $fstart ) );
       }
   }

#
# process_frag( $frag_num, $frag_pos, $dir, $frag_seq ) - handles the output 
# for one fragment - either fragment summary information (if $opt_F) or 
# all tags within the fragement.  $dir is either "f", "r" or "fr" which 
# indicates that forward tags, reverse tags, or both directions should be
# printed.
#
sub  process_frag
   {
    my ( $frag_num, $frag_pos, $dir, $frag_seq ) = @_;
    my $i;

    my $len = length( $frag_seq );
    my @apos = matches( $anchenz, $frag_seq );

    $dir = "fr" if ( $opt_I );   # internals => always doing both directions 

    if ( $opt_F )
       { 
         printf "%8d %8d %8d %8d %8d\n", 
                $seqnum, $frag_num, $frag_pos, $len, $#apos+1; 
       }
    else
       {
        if ( @apos )
           {
            if ( $opt_I )
               { 
                for ( $i = 0; $i <= $#apos; $i++ )
                   {
                    forward_anch($apos[$i],$i,$#apos,$frag_num,$frag_seq,$len)
                               if ( $dir =~ /f/ );
                    reverse_anch($apos[$i],$i,$#apos,$frag_num,$frag_seq,$len)
                               if ( $dir =~ /r/ );
                   }
               }
            else
               { 
                forward_anch($apos[$#apos],$#apos,$#apos,$frag_num,$frag_seq,
                             $len) if ( $dir =~ /f/ );
                reverse_anch($apos[0],0,$#apos,$frag_num,$frag_seq,$len)
                                   if ( $dir =~ /r/ );
               }
           }
        }
   }

sub  forward_anch
   {
    my ( $apos, $i, $n, $frag_num, $seq, $len ) = @_;
    my $rank5 = $i+1;
    my $rank3 = ($n + 1) - $i;

    my $stop = $apos + $tag_ext + $anchenz_len;
    $stop = $len if $stop > $len;
    my $start = $apos + $anchenz_len;
    my $fseq = substr( $seq, $start, $stop - $start );
    if ( length( $fseq ) < $tag_ext )
       { 
         $fseq = substr( ($fseq . $linker ), 0, $tag_ext );
         $flags = "S";
       }
    else
       { $flags = ""; }
    if ( $opt_S )
       {
        printf ">%-24.24s f %3d %5d %8d %4d %8d %4d  $flags\n", 
            $fseq, $seqnum, $frag_num, $len-$apos, $rank3, $apos, $rank5;
        print_fasta( substr( $seq, $start ) );
       }
    else
       {
        printf "%-24.24s f %3d %5d %8d %4d %8d %4d  $flags\n", 
            $fseq, $seqnum, $frag_num, $len-$apos, $rank3, $apos, $rank5;
       }
   }


sub  reverse_anch
   {
    my ( $apos, $i, $n, $frag_num, $seq, $len ) = @_;
    my $rank5 = $i+1;
    my $rank3 = ($n + 1) - $i;

    my $start = $apos - $tag_ext;
    $start =  0 if ( $start < 0 );
    my $stop = $apos;
    my $rseq = rc( substr( $seq, $start, $stop - $start ) );
    if ( length( $rseq ) < $tag_ext )
       { 
         $rseq = substr( ($rseq . $linker ), 0, $tag_ext );
         $flags = "S";
       }
    else
       { $flags = ""; }
    if ( $opt_S )
       {
        printf ">%-24.24s r %3d %5d %8d %4d %8d %4d  $flags\n", 
                $rseq, $seqnum, $frag_num, $apos + $anchenz_len, $rank5, 
                $len-($apos + $anchenz_len), $rank3;
        print_fasta( rc( substr( $seq, 0, $stop ) ) );
       }
    else
       {
        printf "%-24.24s r %3d %5d %8d %4d %8d %4d  $flags\n", 
                $rseq, $seqnum, $frag_num, $apos + $anchenz_len, $rank5, 
                $len-($apos + $anchenz_len), $rank3;
       }
   }

# 
# matches( $enz, $seq ) returns a list of matching positions of substring
# $enz in string $seq.
#
sub  matches
   {
    my ($enz, $seq) = @_;

    my $i = 0;
    my $n = length( $seq );
    my @res = ();

    while ( ($i = index( $seq, $enz, $i )) > -1 )
       {
        push( @res, $i );
        $i++;
       } 
    return( @res );
   }


#
# rc( $seq ) returns the reverse complement of $seq
#
sub  rc
   {
    my $s = shift;
    my $n = length( $s );
    my $i, $j, $c;

    my $r = " "x$n;
    for (  $i = $n - 1, $j = 0;  $i >= 0;  $i--, $j++ )
       {
        $c = substr( $s, $i, 1 );
        $c =~tr/acgtmrwsykvhdbnACGTMRWSYKVHDBN/tgcakywsrmbdhvnTGCAKYWSRMBDHVN/;
        substr( $r, $j, 1 ) = $c;
       }
     return( $r );
   }



# 
# routine print_fasta( $seq ) prints out a sequence in FASTA format
# (without the header)
#
sub  print_fasta
   {
    my ( $seq ) = @_;
    my $i;

    my $n = length( $seq );                # calculate length once
    for ( $i = 0; $i < $n; $i++ )          # for each character
       {
        print substr( $seq, $i, 1 );       # print it out
        if ( ( ($i + 1) % 60 ) == 0 )      # every 60 characters
            { print "\n"; }                # put a newline
       }
    print "\n" if ( ( $i % 60 ) != 0 );    # last newline ensures tidy output
   }

sub  version
   {
    $vers = '$Revision: 0.9 $ ';
    $vers =~ s/^\$[^ ]*\ //;
    $vers =~ s/\ *\$ $//;
    print "gsts           version $vers\n";
   }

sub  help
   {
    print "\n";
    version();
    print <<EndOfHelp;

Usage:         gsts [-chvFIV] [-a<seq>] [-e<n>] [-f<seq>] [seq-files ...]

               where [seq-files] are in FASTA format.  stdin is scanned if
               no file specified.

Options:       -a<seq> use <seq> as anchor enzyme sequence (def. CATG)
               -c      treat all sequences as circular
               -e<n>   tag extent <n> (default 17)
               -f<seq> use <seq> as fragmenting enzyme seq (def. ACTAGT)
               -h      print help message
               -l<seq> append linker sequence <seq> to short tags 
                       (default GGATCCGAAGGGGTTCG)
               -v      verbose mode
               -F      print out fragment information, rather than tag
               -I      print out internal tags as well as true GSTs
               -S      print out anchor site to 3' fragment end sequences
                       (fasta format).  Doesn't include linker
               -V      print version
EndOfHelp
    exit;
   }
