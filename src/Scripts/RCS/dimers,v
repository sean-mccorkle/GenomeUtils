head	0.2;
access;
symbols;
locks
	mccorkle:0.2; strict;
comment	@# @;


0.2
date	2003.06.03.20.47.02;	author mccorkle;	state Exp;
branches;
next	0.1;

0.1
date	2003.05.13.21.06.26;	author mccorkle;	state Exp;
branches;
next	;


desc
@read DNA sequences, print out dimer frequencies
@


0.2
log
@added zero-out handling of -p overflows
@
text
@#!/usr/bin/perl
# Program:       dimers
# Programmer:    Sean R. McCorkle
# Language:      perl
#
# Description:   read DNA sequences (fasta or short tag table) and output
#                dimer frequences
#
# Usage:         dimers [-tuTA] [<seqs> ...]
#
#                 -t  - short tags one per line, rather than fasta
#                 -u  - unidirectional (for fasta sequences)
#                 -T  - total only (for fasta sequences) 
#                 -A  - show all dimers including ambiguities
#                 -p  - normalize counts to total to 100%
#                 -n  - numeric specification of dimers (AA=1 1, CG=2 3,...)
#                 -c  - columnar output
#                 -f  - use file basename as title
#
# $Id: dimers,v 0.1 2003/05/13 21:06:26 mccorkle Exp mccorkle $
#

use  Getopt::Std;
use  File::Basename;

                           ################
                           # Main Program #
                           ################

die "bad option\n" unless ( getopts( 'AcfnptTu' ) );

select( ( select(STDOUT), $| = 1 )[0] );
select( ( select(STDERR), $| = 1 )[0] );


@@dimer_list = ();                             # create list of required
foreach $a ( ( 'A', 'C', 'G', 'T' ) )         # dimers
   {
    foreach my $b ( ( 'A', 'C', 'G', 'T' ) )
       {  push( @@dimer_list, "$a$b" );  }
   }

foreach my $d ( @@dimer_list )                 # ensure all required dimers are
   { $dimers{$d} = 0; }                       # count 0 to begin with

if ( $opt_t )
   {
    while ( <> )
       {
        /([A-Za-z]+)/ || die "Can't find a DNA tag on this line: $_";
        process( $1, $1 );
       }
    output() if ( $opt_T );
   }
else
   {
    while ( <> )
       {
        chomp;
        if ( /^>(.*)/ )
           {
            $new_hdr = $1;
            process( $seq, $hdr) if ( $hdr );
            $hdr = $new_hdr;
            $seq = "";
           }
        else
           {
            s/\s//g;
            s/^\d*//;
            $seq .= uc( $_ );
           }
       }
    process( $seq, $hdr ) if ( $hdr );
    output() if ( $opt_T );
   }






                               ###############
                               # Subroutines #
                               ###############


sub  process
   {
    my ( $seq, $hdr ) = @@_;

    $hdr = basename( $ARGV ) if ( $opt_f );
    my $n = length( $seq ) - 1;

    for ( my $i = 0;  $i < $n;  $i++ )
       {
        my $s = substr( $seq, $i, 2 );
        $dimers{$s}++;
        $dimers{rc($s)}++  unless ( $opt_t || $opt_u );
       }
    output( $hdr ) unless ( $opt_T );
   }

#
# Print out the dimer hash table contents, and clear the table
#
sub  output
   {
    my $label = shift;
    my @@dlist = ( $opt_A ? ( sort keys( %dimers ) ) : @@dimer_list );

    if ( $opt_p )                     # if -p, convert counts to normalized
       {                              # percentages, before printing and
        my $n = 0;                    # clearing
        foreach my $d ( @@dlist )
           { $n += $dimers{$d}; }
        foreach my $d ( @@dlist )
           { $dimers{$d} *=  (($n > 0) ? ( 100.0 / $n) : 0.0);  }  
                                      # overflows are zeroed out until I think
                                      # of a better way to handle it.
       }

    if ( $opt_t && (! $opt_A) && (! $opt_T) )
       {
        print "$label " if ( $label );     
        foreach my $d ( @@dlist )
           {
            if ( $opt_p )
               { printf "%4.1f ", $dimers{$d}; }
            else
               { printf "%3d", $dimers{$d}; }
           }
        print "\n";
       }
    else
       {
        if ( $label )
           {
            if ( $opt_c )
               { printf "%15.15s: ", $label; }
            else
               { print "$label:\n"; }
           }
        
        foreach my $d ( @@dlist )
          { 
           my $dp = $d;
           if ( $opt_n )
              {
               $dp =~ s/^([A-Z])/$1 /;
               $dp =~ tr/ACGT/1234/;
              }
           if ( $opt_c )
              { printf scalar( $opt_p ? "%5.3f " : "%10d " ), $dimers{$d}; }
           else
              { printf scalar( $opt_p ? "%s %f\n" : "%s %d\n" ), 
                        $dp, $dimers{$d}; 
              }
          }
        print "\n" if ( $opt_c );
       }
    undef( %dimers );
    foreach my $d ( @@dlist )
       { $dimers{$d} = 0; }
   }

#
# rc( $seq ) returns the reverse complement of $seq
#
sub  rc
   {
    my $s = shift;
    my $n = length( $s );
    my $i, $j, $c;

    my $r = " "x$n;
    for (  $i = $n - 1, $j = 0;  $i >= 0;  $i--, $j++ )
       {
        $c = substr( $s, $i, 1 );
        $c =~tr/acgtmrwsykvhdbnACGTMRWSYKVHDBN/tgcakywsrmbdhvnTGCAKYWSRMBDHVN/;
        substr( $r, $j, 1 ) = $c;
       }
     return( $r );
   }

@


0.1
log
@going public.
@
text
@d20 1
a20 1
# $Id$
d118 3
a120 1
           { $dimers{$d} *= 100.0 / $n; }
@
