#!/usr/bin/perl
# Program:      compare
# Programmer:   Sean R. McCorkle
# Language:     perl
#
# Description:  This analyzes the differences and similarities between the 
#               contigs (splice: mats) of two sequence assemblies.  It can 
#               read contig/lane data from .fasta.screen.ace files (phrap
#               output), simple format (described below, or output from
#               the BNL splice assembler (getlocs).
#
#               Specifically this was implemented to compile before & after
#               differences between subsequent assemblies.
#
#               It prints out equivalences, fusions, fissions, disappearances,
#               appearances, and complexes, based on sequence members alone.
#               It does not perform any sequence comparisions or alignments.  
#               For that you should use a sequence comparison tool such as 
#               MUMmer or FASTA.
#
#               Simple format file:    
#
#                             Contig:  <name>
#                                  lane1
#                                  lane2
#                             Contig:  <name>
#                                  lane3
#                                  lane4
#                                  ...
#
# Usage:        compare <old contig file> <new contig file>
#
# $Id: compare,v 1.4 2000/11/02 17:35:54 mccorkle Exp mccorkle $
#
($file1,$file2) = @ARGV;
'$Revision: 1.4 $ ' =~ /(\d+)\.(\d+)/;
printf "Compare v$1.$2\n";

#
# Read in old file
#
&read_contigs( $file1 );
%old_contig = %contig;
@old_contigs = @contigs;
#
# Read in new file
#
&read_contigs( $file2 );
%new_contig = %contig;
@new_contigs = @contigs;

#
# scan through sequence keys, and establish old-new contig connection
# lists.
#
foreach $b ( keys( %old_contig ) )
   {
    $old_m = $old_contig{$b};
    $new_m = $new_contig{$b};
    #printf "$b: ($old_m) [$new_m]\n" if ( $old_m eq block43 );

    $o = $old_conn{$old_m};
    $n = $new_conn{$new_m};
    $old_conn{$old_m} .= " $new_m " if ( $new_m && ($o !~ /\ $new_m /) );
    $new_conn{$new_m} .= " $old_m " if ( $old_m && ($n !~ /\ $old_m /) );
   }


printf "\n\nMappings for $file1 with respect to $file2\n\n";

foreach $o ( @old_contigs )
   {
    if ( (! $old_conn{$o}) || $old_conn{$o} =~ /^\s*$/ )
       {
        printf "$o vanishes\n";
       }
    else
       {
        @plist = &mklist( $old_conn{$o} );
        if ( $#plist == 0 )                 # either equiv, or fusion
	   {
            $n = $plist[0];
            @nlist = &mklist( $new_conn{$n} );
            if ( $#nlist == 0 )
               {
                die "Fatal @nlist <-> $o\n" if $nlist[0] ne $o;
                printf "$o is equivalent to $n\n";
	       }
            else
               {
                if ( &back_check( $n, @nlist ) )
                   { printf "$o fuses into $n\n"; }
                else
                   { printf 
		     "$o is completely contained by $n (not a clean fusion)\n";
                   }
	       }
           }
        else
           {
            if ( &forward_check( $o, @plist ) )
               { printf "$o fissions into %s\n", join( ', ', @plist ); }
            else
               { printf 
                    "$o splits into %s (not a clean fusion)\n", 
                    join( ', ', @plist );
               }
	   }
       }
   }

printf "\n\nMappings for $file2 with respect to $file1\n\n";

foreach $n ( @new_contigs )
   {
    if ( (! $new_conn{$n}) || $new_conn{$n} =~ /^\s*$/ )
       {
        printf "$n appears\n";
       }
    else
       {
        @nlist = &mklist( $new_conn{$n} );
        if ( $#nlist == 0 )                 # either equiv, or fusion
	   {
            $o = $nlist[0];
            @olist = &mklist( $old_conn{$o} );
            if ( $#olist == 0 )
               {
                die "Fatal @olist <-> $n\n" if $olist[0] ne $n;
                printf "$n is equivalent to $o\n";
	       }
            else
               {
                if ( &forward_check( $o, @olist ) )
                   { printf "$n is a fission product of $o\n"; }
                else
                   { printf 
		    "$n is a complete subset of $o (not a clean fission)\n";
                   }
	       }
           }
        else
           {
            if ( &back_check( $n, @nlist ) )
               { printf "$n is a fusion of %s\n", join( ', ', @nlist ); }
            else
               { printf 
                    "$n is a join of %s (not a clean fusion)\n", 
                    join( ', ', @nlist );
               }
	   }
       }
   }



                              ###############
                              # Subroutines #
                              ###############


sub back_check
   {
    my ( $n, @nlist ) = @_;

    my $okay = 1;
    foreach $o ( @nlist )
      {
       my @olist = &mklist( $old_conn{$o} );
       if ( $#olist != 0 )
          { 
           $okay = 0;
           last;
          }
       die "back_check: fatal $n <-> $olist[0]\n" if ( $olist[0] ne $n );
      }
    $okay;
   }


sub forward_check
   {
    my ( $o, @olist ) = @_;

    my $okay = 1;
    foreach $n ( @olist )
      {
       my @nlist = &mklist( $new_conn{$n} );
       if ( $#nlist != 0 )
          { 
           $okay = 0;
           last;
          }
       die "back_check: fatal $o <-> $nlist[0]\n" if ( $nlist[0] ne $o );
      }
    $okay;
   }

#
# read_contigs( $file ) 
#
sub read_contigs
   {
    my $file  = $_[0];

    #
    # open the file and peek at the first two lines
    #
    open( INPUT, "$file" ) || die "Can't open $file\n";
    my $line1 = <INPUT>;
    my $line2 = <INPUT>;
    close( INPUT );

    #
    # Now, using these two lines, try to identify the file type
    #
    if ( ( $line1 =~ /^\>block\d+:/ ) && 
         ( $line2 =~ /^\s+\;[^\:]+\:/ ) )
        { read_splicef( $file ); }           # splice format
    elsif( ( $line1 =~ /^AS\s+\d+\s+\d+/ ) &&
           ( $line2 =~ /^\s*$/ ) )
        { read_acef( $file ); }              # ace format
    elsif( $line1 =~ /^Contig:/ )
        { read_simplef( $file ); }           # simple format
    else 
        { die "Can't identify file type: \"$file\"\n"; }
   }

#
# read_splicef( $file ) - read contigs from splice format (getlocs) file
# and set globals @contigs and %contig
#
sub read_splicef
   {
    my $file  = shift;

    open( INPUT, "$file" ) || die "Can't reopen $file\n";
   
    @contigs = ();                                       # reset globals
    %contig = ();

    while ( $_ = <INPUT> )
       {
	next if ( /^\s*$/ );                             # skip blank lines
        if ( /^\>(block\d+):/ )                          # new contig
           {
            $current_contig = $1;
            push( @contigs, $current_contig );
           }
        elsif ( /^\s+\;([^\:]+)\:/ )                     # lane
           {
            my ( $id, $name, $dir ) = parse_splice_lane( $1 );
            die "non unique id $id ($name) in $file!\n" if ( $contig{$id} );
            $contig{$id} = $current_contig;
           }
        else
           {
            die "Bad line: $_";
           }
       }
    close( INPUT );
    printf "$file loaded (splice format)\n";
   }


sub parse_splice_lane
   {
    my $s = shift;

    my ( $dir, $id ) = ("","");
    $dir = "r" if ( $s =~ s/\.r$// );
    if ( $s =~ /\-(\d+[ab]?)\-(\d+[abcdef]?)((\-[^\-]+)|(\-J.*))?$/i )
       { ($gel,$ln) = ($1,$2);
         $ln =~ /^(\d+)([abcdef]?)/;
         $id = sprintf "$gel%d%s", $1, $2; }
    elsif ( $s =~ /^ctg/i )
       { $id = "$s"; }
    else
       { die "bad member: [$s]\n"; }
    return( ( $id, $s, $dir ) );
   }

#
# read_acef( $file ) - read contigs from ace format (phrap) file
# and set globals @contigs and %contig
#
sub read_acef
   {
    my $file  = shift;

    open( INPUT, "$file" ) || die "Can't reopen $file\n";
   
    @contigs = ();                                       # reset globals
    %contig = ();

    $_ = <INPUT>;                                        # get AS line
    /^AS\s+(\d+)\s+(\d+)/;
    my ( $num_contigs, $total_reads ) = ( $1, $2 );
    #
    # Note: put in a check against what we get below!!!!
    #

    while ( $_ = <INPUT> )
       {
        if ( /^CO\s+(\S+)\s/ )
           { 
            $current_contig = $1;
            push( @contigs, $current_contig );
           }
        elsif ( /^AF\s+(\S+)\s/ )
           { 
            my $id = $1;
            die "non unique id $id ($name) in $file!\n" if ( $contig{$id} );
            $contig{$id} = $current_contig;
           }
    
       }

    close( INPUT );
    printf "$file loaded (ace format)\n";
   }

#
# read_simplef( $file ) - read contigs from simple format file
# and set globals @contigs and %contig
#
sub read_simplef
   {
    my $file  = shift;

    open( INPUT, "$file" ) || die "Can't reopen $file\n";
   
    @contigs = ();                                       # reset globals
    %contig = ();

    while ( $_ = <INPUT> )
       {
	next if ( /^\s*$/ );                             # skip blank lines
        if ( /^Contig:\s+(\S+)/ )                          # new contig
           {
            $current_contig = $1;
            push( @contigs, $current_contig );
           }
        elsif ( /^\s*(\S+)/ )                     # lane
           {
            my $id = $1;
            die "non unique id $id ($name) in $file!\n" if ( $contig{$id} );
            $contig{$id} = $current_contig;
           }
        else
           {
            die "Bad line: $_";
           }
       }
    close( INPUT );
    printf "$file loaded (simple format)\n";
   }

sub mklist

   {
    my $l = shift;
    $l =~ s/^\s*//;
    $l =~ s/\s*$//;
    split( /\s+/, $l );
   }



