#!/usr/bin/perl
# Program:       gsts
# Programmer:    Sean R. McCorkle
# Language:      perl
#
# Description:   Reads genome sequences, prints out table of Genome Sequence
#                Tags (GSTs)
#
# Usage:         gsts [-cFI] [-a<seq>] [-f<seq>] [seq-file [seq-file ...] ]
#
#                where [seq-files] are in FASTA format.  stdin is scanned if
#                no file specified.
#
#                 -c      treat all sequences as circular
#                 -a<seq> use <seq> as anchor enzyme sequence (def. CATG)
#                 -f<seq> use <seq> as fragmenting enzyme seq (def. GCGGCCGC)
#                 -l<seq> append linker sequence <seq> to short tags 
#                         (default GGATCCGAAGGGGTTCG)
#                 -F      print out fragment information, rather than tag
#                 -I      print out internal tags as well as true GSTs
#                 -v      verbose mode
#
#                Note to self: consider options for adding fragment offsets to
#                tag positions as well, taglengths, etc.
#
#                (note: sequences are not regular expressions (yet))
#
# $Id: gsts,v 0.1 2002/07/02 18:42:24 mccorkle Exp mccorkle $
#

use  Getopt::Std;



die "bad option\n" unless ( getopts( 'ca:f:l:FIv' ) );


$anchenz  = $opt_a ? uc( $opt_a ) : 'CATG';  # anchoring enzyme default NlaIII 
#$fragenz  = $opt_f ? uc( $opt_f ) : 'GGATCC'; # frag'ing enzyme default BamHI 
$fragenz  = $opt_f ? uc( $opt_f ) : 'GCGGCCGC';  # frag'ing enzyme, def. NotI 
$linker = $opt_l ? uc( $opt_l ) : 'GGATCCGAAGGGGTTCG';

$tag_len     = 17;
$anchenz_len = length( $anchenz );
$fragenz_len = length( $fragenz );


                              ################
                              # Main program #
                              ################


while ( <> )                              # continue reading lines until EOF
   {
    chomp;
    if ( /^>(.*)/ )                       # if its a FASTA header, then
       {                                  # grab it, save the file name
        $new_hdr = $1;                    # and if we've got a previously 
        $file = $ARGV;                    # collected sequence, then
        process( $seq, $hdr, $file ) if ( defined( $hdr ) );  # handle it
        $hdr = $new_hdr;                  # and then reset the buffer
        $seq = "";
       }
    else                                  # otherwise, assume its a sequence
       {                                  # line, so append it to the current
        s/\s//g;                          # buffer
        $seq .= uc( $_ );
        if ( $opt_v )
           { print STDERR "$lineno\n" unless ( ++$lineno % 10000 ); }
       }
   }

#
# don't forget to handle the sequence remaining in the buffer before exiting
#
process( $seq, $hdr, $file ) if ( defined( $hdr ) );  


                               ###############
                               # Subroutines #
                               ###############

#
# process( $seq, $hdr, $file ) - split sequence into fragments, and process
# each fragment seperately.   
#
sub  process
   {
    my ( $seq, $hdr, $file ) = @_;
    my $i, $fstart, $fstop;
    $seqnum++;                               # sequence number counter (global)
   
    print STDERR "[$file] $hdr", length( $seq ),"\n" if ( $opt_v );
    print STDERR "$file ", length( $seq ), "\n" if ( $opt_v );
    
    my @fpos = matches( $fragenz, $seq );
    return unless ( @fpos );
    printf STDERR "%12s %10d\n",  $fragenz, $#fpos + 1, "\n" if ( $opt_v );
    #
    # Handle the interior fragments
    #
    for ( $i = 0; $i < $#fpos; $i++ )
       { 
        $fstart = $fpos[$i] + $fragenz_len;  # exclude the frag enz sequence
        $fstop = $fpos[$i+1];
        process_frag( $i+1, $fstart, "fr",
                      substr( $seq, $fstart, $fstop - $fstart ) ); 
       }

    #
    # If the DNA is circular, make a special fragment by concatenating the ends
    #
    if ( $opt_c )
       { 
        $fstart = $fpos[$#fpos] + $fragenz_len;
        process_frag( $i+1, $fstart, "fr",
                      substr($seq, $fstart) . 
                      substr($seq, 0, $fpos[0]) ); 
       }
    else
       {
        process_frag( 0, 0, "f", substr( $seq, 0, $fpos[0] ) );
        process_frag( $#fpos + 1, $fpos[$#fpos], "r", 
                       substr( $seq, $fpos[$$fpos] ) );
       }
   }

#
# process_frag( $frag_num, $frag_pos, $dir, $frag_seq ) - handles the output 
# for one fragment - either fragment summary information (if $opt_F) or 
# all tags within the fragement.  $dir is either "f", "r" or "fr" which 
# indicates that forward tags, reverse tags, or both directions should be
# printed.
#
sub  process_frag
   {
    my ( $frag_num, $frag_pos, $dir, $frag_seq ) = @_;
    my $i;

    my $len = length( $frag_seq );
    my @apos = matches( $anchenz, $frag_seq );

    if ( $opt_F )
       { 
         printf "%8d %8d %8d %8d %8d\n", 
                $seqnum, $frag_num, $frag_pos, $len, $#apos+1; 
       }
    else
       {
        if ( @apos )
           {
            if ( $opt_I )
               { 
                for ( $i = 0; $i <= $#apos; $i++ )
                   {
                    forward_anch($apos[$i],$i,$#apos,$frag_num,$frag_seq,$len)
                               if ( $dir =~ /f/ );
                    reverse_anch($apos[$i],$i,$#apos,$frag_num,$frag_seq,$len)
                               if ( $dir =~ /r/ );
                   }
               }
            else
               { 
                forward_anch($apos[$#apos],$#apos,$#apos,$frag_num,$frag_seq,
                             $len) if ( $dir =~ /f/ );
                reverse_anch($apos[0],0,$#apos,$frag_num,$frag_seq,$len)
                                   if ( $dir =~ /r/ );
               }
           }
        }
   }

sub  forward_anch
   {
    my ( $apos, $i, $n, $frag_num, $seq, $len ) = @_;
    my $rank5 = $i+1;
    my $rank3 = ($n + 1) - $i;

    my $stop = $apos + $tag_len + $anchenz_len;
    $stop = $len if $stop > $len;
    my $start = $apos + $anchenz_len;
    my $fseq = substr( $seq, $start, $stop - $start );
    if ( length( $fseq ) < $tag_len )
       { 
         $fseq = substr( ($fseq . $linker ), 0, $tag_len );
         $flags = "S";
       }
    else
       { $flags = ""; }
    printf "%-24.24s f %3d %5d %8d %4d %8d %4d  $flags\n", 
            $fseq, $seqnum, $frag_num, $len-$apos, $rank3, $apos, $rank5;
   }


sub  reverse_anch
   {
    my ( $apos, $i, $n, $frag_num, $seq, $len ) = @_;
    my $rank5 = $i+1;
    my $rank3 = ($n + 1) - $i;

    my $start = $apos - $tag_len;
    $start =  0 if ( $start < 0 );
    my $stop = $apos;
    my $rseq = rc( substr( $seq, $start, $stop - $start ) );
    if ( length( $rseq ) < $tag_len )
       { 
         $rseq = substr( ($rseq . $linker ), 0, $tag_len );
         $flags = "S";
       }
    else
       { $flags = ""; }
    printf "%-24.24s r %3d %5d %8d %4d %8d %4d  $flags\n", 
            $rseq, $seqnum, $frag_num, $apos + $anchenz_len, $rank5, 
            $len-($apos + $anchenz_len), $rank3;
   }

# 
# matches( $enz, $seq ) returns a list of matching positions of substring
# $enz in string $seq.
#
sub  matches
   {
    my ($enz, $seq) = @_;

    my $i = 0;
    my $n = length( $seq );
    my @res = ();

    while ( ($i = index( $seq, $enz, $i )) > -1 )
       {
        push( @res, $i );
        $i++;
       } 
    return( @res );
   }


#
# rc( $seq ) returns the reverse complement of $seq
#
sub  rc
   {
    my $s = shift;
    my $n = length( $s );
    my $i, $j, $c;

    my $r = " "x$n;
    for (  $i = $n - 1, $j = 0;  $i >= 0;  $i--, $j++ )
       {
        $c = substr( $s, $i, 1 );
        $c =~tr/acgtmrwsykvhdbnACGTMRWSYKVHDBN/tgcakywsrmbdhvnTGCAKYWSRMBDHVN/;
        substr( $r, $j, 1 ) = $c;
       }
     return( $r );
   }

