head	0.5;
access;
symbols;
locks
	mccorkle:0.5; strict;
comment	@// @;


0.5
date	2002.05.02.21.28.45;	author mccorkle;	state Exp;
branches;
next	0.4;

0.4
date	2002.04.11.21.30.05;	author mccorkle;	state Exp;
branches;
next	0.3;

0.3
date	2002.04.11.19.04.11;	author mccorkle;	state Exp;
branches;
next	0.2;

0.2
date	2002.04.10.21.38.23;	author mccorkle;	state Exp;
branches;
next	0.1;

0.1
date	2002.04.10.18.43.59;	author mccorkle;	state Exp;
branches;
next	;


desc
@re-organizing L. Brenner's original code, and making the same program
do double duty: self-checks in one sequence list, or cross-checks between
two.
@


0.5
log
@fixed the problem with null descriptions.
@
text
@// Program:      lossc
// Programmers:  Lawrence Brenner, initial development Aug, 2001.
//               updated by Sean McCorkle, Mar 2002
// Language:     C++, with STL
//
// Description:  Lots of short sequence comparisons.
//
// Usage:        lossc [-hmV] [-v<n>] <thresh> <data seqs> [<db seqs>]
//  
//               <thresh> is an integer indicated the maximum edit distance
//                        considered for a match 
//               <data seqs> is a file of short sequences and descriptions
//               <db seqs>  is a file of short sequences and descriptions
//
//                 -m  show misses as well as hits
//                 -v<n>  verbosity level n (1, 2, ...) higher means more mess.
//                 -h     print usage message, then exit
//                 -V     print version, then exit
//
// $Id: lossc.c++,v 0.4 2002/04/11 21:30:05 mccorkle Exp mccorkle $
//
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <stl.h>
#include <stdlib.h>
#ifndef SOLARIS        /* Sun's are really a pain in the neck sometimes */
#include <unistd.h>
#endif


static char const rcsid[] = "$Id: lossc.c++,v 0.4 2002/04/11 21:30:05 mccorkle Exp mccorkle $";

#define  LARGE 1000000

const int  max_num_seqs = 100000;    // maximum number of sequences
const int  max_seq_size  = 100;      // max length of the sequences is maxtrix
                                     // size.
int        min_seq_length;           // set by main()
int        misses;                   // set by -m option in GetArgs
int        verbosity;                // set by -v option in GetArgs

static  int   EdDist[max_seq_size][max_seq_size]; //The Smith-Waterman matrix

//
// usage() - print usage message and bomb out
//
void usage( void )
   {
    cout << "Usage:  lossc [-hmV] [-v<n>] <thresh> <seqfile> [<seqfile2>]\n";
    exit( 1 );
   }

//
// spacer( c, n ) - return a string of n c's
//
string spacer( char c, int n )
   {
    string b( n, c );
    return( b );
   }

//
// GetArgs() - parse args for options and set global values accordingly,
// and then extract edit_threshold and filenames and return them.
//

void GetArgs( int     argc,         // input- argc from main( argc, argv )
              char   *argv[],       // input- argv from main( argc, argv )
              int    &edit_thresh,  // output- edit distance threshold
              string &file1,        // output- mandatory filename
              string &file2         // output- optional 2nd file or "" if none
            )
   {
    extern char *optarg;
    extern int   optind;
    int          c;

    misses = 0;
    verbosity = 0;

    while ( (c = getopt( argc, argv, "hmv:V")) != -1 )
        switch ( c )
           {
            case 'm':  misses = 1;
                       break;
            case 'v':  verbosity = atoi( optarg );
                       break;
            case 'V':  cout << "lossc, $Revision: 0.4 $\n";
                       break;
            case 'h':  
            default:
                       usage();
           }
    argc -= optind;
    argv += optind;

    if ( argc < 2 )
        usage();

    edit_thresh = atoi(argv[0]);
    file1 = argv[1];
    if ( argc > 2 )
        file2 = argv[2];
    else
        file2 = "";
   }


// note to self: put in lots of input checks, including max seq length
// check.

void  Load_Sequences(  string         filename,   // input- short seq filename
                       vector<string> &sequences,  // output- array of seqs
                       vector<string> &descrip,    // output- corres. descrips
                       int            &count       // 
                    )
 {
  ifstream           in; 
  string             line;
  int                i = 0;
  int                k;

  in.open( filename.c_str() );
  if ( ! in )
    {
      cerr << "Can not open "<< filename.c_str() << "\n";
      exit;
    }

  while ( ! in.eof() )
    {
      getline(in, line);
      k = line.find( ' ' );
      if ( verbosity > 1 )
          cout << "k " << k << " line: [" << line << "] " 
               << line.length() << "\n";
      if ( k > 0 )
        {
         sequences[i] = line.substr( 0, k );
         descrip[i] = line.substr( k+1, line.length() );
         if ( verbosity > 1 )
             cout << "input: [" << sequences[i] << "] [" << descrip[i] 
                  << "]\n";
         i++;
	}
      else if ( line.length() > 0 )
        {
         sequences[i] = line;
         descrip[i] = ' ';
         if ( verbosity > 1 )
             cout << "input: [" << sequences[i] << "] [" << descrip[i] 
                  << "]\n";
         i++;
        }
    }
    in.close();
    count = i; //i - 1; - why was this here?
    if ( verbosity == 1 )
        cout << count << " sequences in file " << filename << "\n";

    sequences.resize( count );
    descrip.resize( count );
} 

//
// min_length() returns the minium length of the seqs in the vector
//
int   min_length( vector<string> seqs )
   {
    vector<string>::iterator s;
    int                      min = max_seq_size + 1;

    for ( s = seqs.begin();  s != seqs.end();  s++ )
        if ( (*s).length() < min )
            min = (*s).length();
    if ( verbosity > 0 )
        cout << "Min length " << min << "\n";
    return( min );
   }

//
// trunc_lengths() truncates all seqs down to size len
//
void  trunc_lengths( vector<string> &seqs,  int len )
   {
    vector<string>::iterator s;
    
    for ( s = seqs.begin();  s != seqs.end();  s++ )
        if ( (*s).length() > len )
           {
            if ( verbosity > 1 )
                cout << "    truncating " << *s;
	    (*s).erase( ((*s).begin() + len), (*s).end() );
            if ( verbosity > 1 )
                cout << " to " << *s << "\n";
           }
   }

               ///////////////////////////////
               // Edit distance calculation //
               ///////////////////////////////
//
// Fills the very top row and left column with increasing scores
//
void  Initialize_Matrix( void )
   {
    int row;
    int col;

    for ( row = 0; row < max_seq_size; row++ ) //Sets the values of r,0 
        EdDist[row][0] = row;

    for ( col = 1; col < max_seq_size; col++ ) //Sets the values of 0,c 
        EdDist[0][col] = col;
   }


//
// UpdateMin() - selects the minimum score at EdDist[row,col], which may 
// necessitate checking seq1[row-1] and seq2[col-1].  Returns the minimum
// value in final
//
void  UpdateMin( int     row,   // input- row number for evaluation
                 int     col,   // input- col number for evaluation
                 string  seq1,  // input- 1st short sequence
                 string  seq2,  // input- 2nd short sequence
                 int    &final    // output- minimum value
               )
   {
    int           b = 0;          //Used in the substitution, match function.
  

    if ( seq1[row - 1] == seq2[col - 1] ) //Checks for matches.
        b = 0;
    else                                     // Checks for substituitons.
        b = 1;
  
    final = EdDist[row - 1][col - 1] + b;    // - 1;
  
    if ( EdDist[row - 1][col] + 1 < final )  // Checks for insertions.
        final = EdDist[row - 1][col] + 1;
    if ( EdDist[row][col - 1]  + 1 < final ) // Checks for deletions.
        final  = EdDist[row][col - 1] + 1; 

    EdDist[row][col] = final; //++final;
   }

// This version of Edit_Distance counts on the previous values of
// EdDist[r][c] from the previous sequence comparsion to be present,
// up to the subsquare determined by start_diag.  

// returns:  dist - edit distance (or threshold + 1 if aborted)
//           last_diag - matrix diag indicates where calculation stopped 
//                       (< seq.length() if aborted early because threshold
//                        exceeded)

void Edit_Distance( string seq1,        // input- first short sequence 
		    string seq2,        // input- 2nd short sequence 
		    int    threshold,   // input- abort if dist > threshold
		    int    start_diag,  // input- recalculate mat @@ this column
		    int    &last_diag,  // output- last diag calc. before abort
		    int    &dist )      // output- resultant distance
   {
    int  eta = 0;                // Minimum edit distance changes.
    int  min;                    // The lowest calculated value at one position
    int  r, c;                   // row and column counters
 
    int  rows = seq1.length();   // number of rows in the matrix
    int  cols = seq2.length();   // number of columns
    int  diag;                   // Variable that analyzes only the revelant diagonals.

    // Begin filling the matrix EdDist[r][c] in subsquares, starting
    // in the upper right corner, or actually at the specified start position

    for ( diag = start_diag; ((diag <= rows) && (eta <= threshold)); diag++ )
       {
        eta = EdDist[0][diag];
        for (  r = 1;  r < diag;  r++  )         // do the column
	   {
	    UpdateMin( r, diag, seq1, seq2, min );
	    if ( min < eta )
	        eta = min;
           }

        for (  c = 1;  c <= diag;  c++  )        // now do the row
	   {
	    UpdateMin( diag, c, seq1, seq2, min );
            if ( min < eta )
               eta = min;
           }
       }
 
    if ( eta > threshold )
        dist = threshold + 1;    
    else
        dist = EdDist[rows][cols];

    last_diag = diag;
   }


//
// first_diff( a, b ) returns the index of the first position where
// strings a & b differ.  (Note: we assume both strings are the same length 
// - is this always going to be true?
//
int  first_diff( string a, string b )
   {
    int i = 0; 

    while ( ( i < a.length() ) && ( a[i] == b[i] ) )  
        i++;
    return i;
   }


void  Cross_Compare( int             edit_thresh,
                     vector <string> tags, 
                     vector <string> tag_descrip, 
                     int             tcount, 
                     vector <string> database, 
                     vector <string> db_descrip, 
                     int             dcount
                   )
   {
    int             t;              // database sequence index
    int             d;              // counter for the database.
    int             ed;             // edit distance between the sequences.
    int             same;           // difference between the two sequences.
    int             last = LARGE;  // last col position calculated in matrix.
    int             best_ed;

    for ( t = 0; t < tcount; t++ ) //Checks the tags to the database.
       {
        best_ed = edit_thresh + 1;
        for ( d = 0; d < dcount; d++ )
           { 
            if ( d == 0 )
                same = 0;
            else
                same = first_diff( database[d - 1], database[d] ); 

            // if we aborted early the previous time, and this sequence
            // is the same BEYOND that point, then there's no need to 
            // to bother - this one doesn't match in the threshold either.

            if ( same < last )
               {
                Edit_Distance( tags[t], database[d], edit_thresh, same, 
                               last, ed );
                if ( ed <= edit_thresh )
                   {
                    cout << tags[t] << " " << database[d] << " " << ed <<
                         " " << tag_descrip[t] << "|" << db_descrip[d] << "\n";
                    best_ed = ed;
                   }
               }
           }
        if ( misses && ( best_ed > edit_thresh ) )  // no hits, print miss output
            cout << tags[t] << " " << spacer( '-', min_seq_length )
                 << " X " <<tag_descrip[t]<<"\n";

       }   
   }


void  Self_Compare( int             edit_thresh,
                    vector <string> tags, 
                    vector <string> tag_descrip, 
                    int             tcount )
   {
    int             i, j;
    int             same;           // difference between the two sequences.
    int             last = LARGE;  // last col position calculated in matrix.
    int             ed;
    int             best_ed;

    if ( verbosity > 1 )
        cout << "Self check\n";

    for ( i = 0; i < tcount; i++ )
       {
        best_ed = edit_thresh + 1;
        for ( j = i+1; j < tcount; j++ )
           {
            if ( j == i + 1 )
                same = 0;
            else
                same = first_diff( tags[j - 1], tags[j] ); 

            // if we aborted early the previous time, and this sequence
            // is the same BEYOND that point, then there's no need to 
            // to bother - this one doesn't match in the threshold either.

            if ( same < last )
               {
                Edit_Distance( tags[i], tags[j], edit_thresh, same, 
                               last, ed );
                if ( ed <= edit_thresh )
                   {
                    cout << tags[i] << " " << tags[j] << " " << ed << " " <<
                         tag_descrip[i] << "|" << tag_descrip[j] << "\n";
                    best_ed = ed;
                   }
               }
           }
        if ( misses && ( best_ed > edit_thresh ) )  // no hits, print miss output
            cout << tags[i] << " " << spacer( '-', min_seq_length ) 
                 << " X " <<tag_descrip[i]<<"\n";
       }
   }

                           //////////////////
                           // Main Program //
                           //////////////////


int  main( int argc, char *argv[] )
  
   {
    int             dcount; //The counter for the database.
    int             tcount; //The counter for the tags.
    int             edit_thresh; //How much of an edit distance you want.
    int             minl2;
    vector <string> tags(max_num_seqs); //The vector of tags that are to be checked against the databse.
    vector <string> database(max_num_seqs); //The vector of sequences that are in the databse.
    vector <string> tag_descrip(max_num_seqs);
    vector <string> db_descrip(max_num_seqs);
    string          file1;
    string          file2;

    GetArgs( argc, argv, edit_thresh, file1, file2 );

    Initialize_Matrix();

    Load_Sequences( file1, tags, tag_descrip, tcount );    // read data tags
    min_seq_length = min_length( tags );
    if ( file2 != "" ) // read database tags
       {
        Load_Sequences( file2, database, db_descrip, dcount ); 
        minl2 = min_length( database );
        if ( minl2 < min_seq_length ) 
            min_seq_length = minl2;
        trunc_lengths( tags, min_seq_length );        
        trunc_lengths( database, min_seq_length );        
        sort( database.begin(), database.end() );  // sort alphabetically
        Cross_Compare( edit_thresh, tags, tag_descrip, tcount, 
                     database, db_descrip, dcount );
       }
    else
       {
        trunc_lengths( tags, min_seq_length );        
        sort( tags.begin(), tags.end() );
        Self_Compare( edit_thresh, tags, tag_descrip, tcount );
       }

   }



@


0.4
log
@cleaning up a bit, commenting.
@
text
@d20 1
a20 1
// $Id: lossc.c++,v 0.3 2002/04/11 19:04:11 mccorkle Exp mccorkle $
d33 1
a33 1
static char const rcsid[] = "$Id: lossc.c++,v 0.3 2002/04/11 19:04:11 mccorkle Exp mccorkle $";
d90 1
a90 1
            case 'V':  cout << "lossc, $Revision: 0.3 $\n";
d137 2
a138 1
          cout << "k " << k << " line: [" << line << "]\n";
d148 9
@


0.3
log
@okay - got string truncation working, and added in options and an optional 2nd file name.
@
text
@d20 1
a20 1
// $Id: lossc.c++,v 0.1 2002/04/10 18:43:59 mccorkle Exp mccorkle $
d33 1
a33 1
static char const rcsid[] = "$Id: lossc.c++,v 0.1 2002/04/10 18:43:59 mccorkle Exp mccorkle $";
d90 1
a90 1
            case 'V':  cout << "lossc, $Revision$\n";
d157 3
a159 2
// returns the minium length of the seqs in the vector

d173 3
d190 7
a196 1
 
d210 13
a222 8
void  Position_Evaluation( int    row,   // input- row number for evaluation
                           int    col,   // input- col number for evaluation
                           string seq1,  // input- 1st short sequence
                           string seq2,  // input- 2nd short sequence
                           int &final    // output- minimum value
                         )
{
   int           b = 0;                      //Used in the substitution, match function.
a223 1
   //cout << "Pos Eval for [" << row << "][" << col << "] of seqs [" << seq1 << "] and [" << seq2 << "]\n";     
d225 4
a228 9
  if ( seq1[row - 1] == seq2[col - 1] ) //Checks for matches.
    {    
      b = 0;
    }    
  else //Checks for substituitons.
    {
      b = 1;
    }
  final = EdDist[row - 1][col - 1] + b; // - 1;
d230 1
a230 15
  //cout << "b is: " << b << " and final is: " << final << "\n";

	 
  if ( EdDist[row - 1][col] + 1 < final ) //Checks for insertions.
    {    
      final = EdDist[row - 1][col] + 1;
      // cout << "Final for the insertion at EdDist[" << row << "][" << col << "] is: " << final << "\n";
    }
  if ( EdDist[row][col - 1]  + 1 < final ) //Checks for deletions.
    {    
      final  = EdDist[row][col - 1] + 1; 
      //      cout << "Final for the deletion  at EdDist[" << row << "][" << col << "] is: " << final << "\n";
      
    }
  EdDist[row][col] = final; //++final;
d232 4
d237 2
a238 1
}
d241 2
a242 1
// EdDist[r][c].
d245 3
a247 1
//           last_col - matrix column where calculation stopped 
d252 3
a254 3
		    int    start_col,   // input- recalculate mat @@ this column
		    int    &last_col,   // output- last col calc. before abort
		    int    &dist )      // output-resultant distance
d267 1
a267 1
    for ( diag = start_col; ((diag <= rows) && (eta <= threshold)); diag++ )
d272 1
a272 1
	    Position_Evaluation( r, diag, seq1, seq2, min );
d279 1
a279 1
	    Position_Evaluation( diag, c, seq1, seq2, min );
d283 1
a283 1
    }
d290 2
a291 3
  last_col = diag;
}

d294 1
d298 1
a298 1

d318 1
a318 1
    int             t;       // database sequence index
d322 1
a322 1
    int             lastp = LARGE;  // last col position calculated in matrix.
d339 1
a339 1
            if ( same < lastp )
d342 1
a342 1
                               lastp, ed );
d366 1
a366 1
    int             lastp = LARGE;  // last col position calculated in matrix.
d387 1
a387 1
            if ( same < lastp )
d390 1
a390 1
                               lastp, ed );
@


0.2
log
@looking pretty good.  saving and then adding in min length trimming.
@
text
@d5 1
d7 2
a8 1
// Usage:        lossc <thresh> <data seqs> [<db seqs>]
d15 5
d28 3
d37 1
a37 1
const int max_num_seqs = 100000;     // maximum number of sequences
d40 39
d80 2
a81 2
int  misses   = 0;  
int  verbosity = 0;
d83 18
a100 1
static  int   EdDist[max_seq_size][max_seq_size]; //The Smith-Waterman matrix
d102 7
a108 1
string          blanks( "-----------------" ); // make this variable
d114 1
a114 1
void  Load_Sequences(  char           *filename,   // input- short seq filename
d125 1
a125 1
  in.open(filename);
d128 1
a128 1
      cerr << "Can not open "<< filename << "\n";
d164 1
a164 1
    for ( s = seqs.begin();  s != seqs.end;  s++ )
d167 2
d172 15
d349 2
a350 1
            cout << tags[t] << " " << blanks << " X " <<tag_descrip[t]<<"\n";
d397 2
a398 1
            cout << tags[i] << " " << blanks << " X " <<tag_descrip[i]<<"\n";
d413 1
d418 2
d421 1
a421 2

    edit_thresh = atoi(argv[1]);
d425 3
a427 3
    Load_Sequences(argv[2], tags, tag_descrip, tcount);    // read data tags

    if ( argc > 3 ) // read database tags
d429 6
a434 1
        Load_Sequences(argv[3], database, db_descrip, dcount); 
d441 1
@


0.1
log
@So far so good - I'm about to insert the last version of Edit_Distance
to take advantage of sorted lists.
@
text
@d7 5
d13 1
a13 1
// $Id$
d23 3
a25 1
static char const rcsid[] = "$Id$";
d31 2
a32 1
int  verbosity = 1;
d39 59
d111 6
a116 3


void Position_Evaluation(int row, int col, string seq1, string seq2, int &final )
d151 2
d154 2
d157 6
a162 6


int  Edit_Distance( string seq1,   // input- first short sequence
                    string seq2,   // input- 2nd short sequence
                    int threshold  // input- abort if dist > threshold
                  )
d165 2
a166 3
    int  min;                    // The lowest calculated value.
    int  r = 0;                  // row counter
    int  c = 0;                  // column counter
d172 4
a175 1
    for ( diag = 1;  diag <= rows && eta <= threshold; diag++ )
d178 10
a187 3
        for ( r = 1; r < diag; r++ )
           {
            Position_Evaluation( r, diag, seq1, seq2, min );
d189 1
a189 7
                eta = min;
           } 
        for ( c = 1; c <= diag; c++ )
           {
            Position_Evaluation( diag, c, seq1, seq2, min );
            if ( min < eta )
                eta = min;
d191 4
a194 3
       }
    if ( eta > threshold)
        return threshold + 1;    
d196 3
a198 1
        return EdDist[rows][cols];
a202 46
// note to self: put in lots of input checks, including max seq length
// check.

void  Load_Sequences(  char           *filename,   // input- short seq filename
                       vector<string> &sequences,  // output- array of seqs
                       vector<string> &descrip,    // output- corres. descrips
                       int            &count       // 
                    )
 {
  ifstream           in; 
  string             line;
  int                i = 0;
  int                k;

  in.open(filename);
  if ( ! in )
    {
      cerr << "Can not open "<< filename << "\n";
      exit;
    }

  while ( ! in.eof() )
    {
      getline(in, line);
      k = line.find( ' ' );
      if ( verbosity > 1 )
          cout << "k " << k << " line: [" << line << "]\n";
      if ( k > 0 )
        {
         sequences[i] = line.substr( 0, k );
         descrip[i] = line.substr( k+1, line.length() );
         if ( verbosity > 1 )
             cout << "input: [" << sequences[i] << "] [" << descrip[i] 
                  << "]\n";
         i++;
	}
    }
    in.close();
    count = 1; //i - 1; - why was this here?
    if ( verbosity == 1 )
        cout << count << " sequences in file " << filename << "\n";

    sequences.resize( count );
    descrip.resize( count );
} 

d216 9
a224 8
void  Cross_Check( int             edit_thresh,
                   vector <string> tags, 
                   vector <string> tag_descrip, 
                   int             tcount, 
                   vector <string> database, 
                   vector <string> db_descrip, 
                   int             dcount
                 )
d227 4
a230 3
    int             data;    // The counter for the database.
    int             ed;    // The edit distance between the sequences.
    int             seqdiff; // The difference between the two sequences.
d236 1
a236 1
        for ( data = 0; data < dcount; data++ )
d238 2
a239 2
            if ( data == 0 )
                seqdiff = 0;
d241 1
a241 1
                seqdiff = first_diff( database[data - 1], database[data] ); 
d243 15
a257 7
            ed = Edit_Distance(tags[t], database[data], edit_thresh);
            if ( ed <= edit_thresh )
    	       {
                cout << tags[t] << " " << database[data] << " " << ed <<
		     " " << tag_descrip[t] << "|" << db_descrip[data] << "\n";
                best_ed = ed;
	       }
d259 1
a259 1
        if ( best_ed > edit_thresh )  // no hits, print miss output
d266 4
a269 4
void  Self_Check( int             edit_thresh,
                  vector <string> tags, 
                  vector <string> tags_descrip, 
                  int             tcount )
d272 3
a274 1
    int             seqdiff; // The difference between the two sequences.
d277 2
a278 1
    cout << "Self check\n";
d285 2
a286 2
            if ( data == 0 )
                seqdiff = 0;
d288 1
a288 1
                seqdiff = first_diff( database[data - 1], database[data] ); 
d290 15
d306 2
d338 1
a338 1
        Cross_Check( edit_thresh, tags, tag_descrip, tcount, 
d344 1
a344 1
        Self_Check( edit_thresh, tags, tag_descrip, tcount );
@
