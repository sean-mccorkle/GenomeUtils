head	3.11;
access;
symbols;
locks
	mccorkle:3.11; strict;
comment	@ * @;


3.11
date	2007.11.13.19.31.54;	author mccorkle;	state Exp;
branches;
next	3.10;

3.10
date	2003.03.18.13.16.23;	author mccorkle;	state Exp;
branches;
next	3.9;

3.9
date	2003.03.14.11.08.30;	author mccorkle;	state Exp;
branches;
next	3.8;

3.8
date	2003.03.13.19.42.37;	author mccorkle;	state Exp;
branches;
next	3.7;

3.7
date	2003.01.14.21.54.57;	author mccorkle;	state Exp;
branches;
next	3.6;

3.6
date	2000.08.07.14.20.45;	author mccorkle;	state Exp;
branches;
next	3.5;

3.5
date	2000.04.20.20.00.18;	author mccorkle;	state Exp;
branches;
next	3.4;

3.4
date	2000.03.22.01.02.50;	author mccorkle;	state Exp;
branches;
next	3.3;

3.3
date	2000.03.21.20.43.11;	author mccorkle;	state Exp;
branches;
next	3.2;

3.2
date	2000.03.16.19.58.33;	author mccorkle;	state Exp;
branches;
next	3.1;

3.1
date	97.09.30.05.20.09;	author mccorkle;	state Exp;
branches;
next	3.0;

3.0
date	97.04.22.01.35.25;	author mccorkle;	state Exp;
branches;
next	;


desc
@Sequence alignment, display, and difference statistics routines
for comparing DNA sequences.
@


3.11
log
@added handling for non-silent vs silent translation differences.
added handling to encourage gaps to start at codons
@
text
@/* Module:       lpa_align.c                                              */
/* Programmer:   Sean R. McCorkle                                         */
/* Lanuage:      C                                                        */
/* Description:  least-path string alignment routine and associated stuff */
/*                                                                        */
/* $Id: lpa_align.c,v 3.10 2003/03/18 13:16:23 mccorkle Exp mccorkle $ */
/**************************************************************************/

static char lpa_align_rcs_id[] =
      "$Id: lpa_align.c,v 3.10 2003/03/18 13:16:23 mccorkle Exp mccorkle $";

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "seqlib.h"


                         /************************/
                         /* Macros and Constants */
                         /************************/

typedef  unsigned char  BYTE;
 
/* #define  GAPSTART       50 */
/* #define  GAPCONT        4  */ /* was ten */ 
#define  GAPSTART       55 /* 50 */
#define  GAPCONT        40   /* was ten */
#define  INDEL          50  /* insertion/deletion penalty */
#define  SUB            40  /* substitution error penalty */
#define  AMB            0   /* ambiguity subsititution penalty */

#define  UP             0x04     /* these are the backpointer directions    */
#define  DIAG           0x02     /* they are bit masks so that they can be  */
#define  LEFT           0x01     /* or-ed together to indicate combinations */
#define  UNSEEN         0x7FFFFFFF /* must be positive!!! */

#define  INDEL_IND      '-'      /* used in the mid[] array */
#define  AMB_IND        '|'
#define  WRONG_IND      '*'
#define  OK_IND         ' '
#define  INDEL_SPACER   ' '     /* used in top[] and bot[] array's for indels*/



/* Penalty matrix */

char penalty[16][16] = {
/*          a   c   g   t   m   r   w   s   y   k   v   h   d   b   n */
       0,   X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,
/*a*/  X,   0,SUB,SUB,SUB,AMB,AMB,AMB,SUB,SUB,SUB,AMB,AMB,AMB,SUB,AMB,
/*c*/  X, SUB,  0,SUB,SUB,AMB,SUB,SUB,AMB,AMB,SUB,AMB,AMB,SUB,AMB,AMB,
/*g*/  X, SUB,SUB,  0,SUB,SUB,AMB,SUB,AMB,SUB,AMB,AMB,SUB,AMB,AMB,AMB,
/*t*/  X, SUB,SUB,SUB,  0,SUB,SUB,AMB,SUB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,
/*m*/  X, AMB,AMB,SUB,SUB,AMB,AMB,AMB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,
/*r*/  X, AMB,SUB,AMB,SUB,AMB,AMB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,
/*w*/  X, AMB,SUB,SUB,AMB,AMB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*s*/  X, SUB,AMB,AMB,SUB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*y*/  X, SUB,AMB,SUB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*k*/  X, SUB,SUB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*v*/  X, AMB,AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*h*/  X, AMB,AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*d*/  X, AMB,SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*b*/  X, SUB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,
/*n*/  X, AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB,AMB
};

/* This might be a good idea, non? */
/*    static struct diff_s {
                           int  typ;
                           int  top_pos;
                           int  bot_pos;
                           int  top_char;
                           int  bot_char;
                         } diffs[MAX_SEQ_LENGTH];
*/

                         /*************************/
                         /* Function Declarations */
                         /*************************/


void  gen_alignment( BYTE *backpnt, int m, int n, 
                     char *seq1, char *seq2,
                     int   max_align_size,
                     int   handle_translation,
                     char *top, char *mid, char *bot, 
                     char *trans_top, char *trans_bot, int *l );

void  pq_init( int m, int n );
int   pq_update( int i, int j, int d );
int   pq_remove( int *i, int *j );
void  pq_upheap( int k );
void  pq_downheap( int k );

#define  ind(x,y) ( (x) * (n+1) + (y) )
#define  MAX(x,y) ( ( (x) > (y) ) ? (x) : (y) )

/* Note: seqs and align arrays should be kept below MAX_SEQ_LENGTH  */
/* Hmmm.  maybe better to have stats generated directly from matrix */
/* and then skip align?  Later!                                     */

void lpa_align( char *char_seq1, int m, /* first (top) sequence & length */
                char *char_seq2, int n, /* 2nd (bottom) sequence & length */
                int   max_align_size,   /* max length of top, mid, bot */
                int   handle_translation, /* 1 if handling translation */
                char *top,          
                char *mid, 
                char *bot,
                char *trans_top,
                char *trans_bot,
                int  *l                 /* resultant length of top, mid, bot */
              )
                
   {
    int          *d;
    BYTE         *backpnt;
    int           size;
    int           i, j;
    int           x, y;
    int           dist;
    int           p;
    int           max_right_lead_offset;
    int           max_down_lead_offset;
    char          *seq1, *seq2;   /* sequential code mapped versions of seqs*/
    int           counter = 0;
    int           gap_t_off;  /* attempt to prefer aa frames */

    /* allocate storage for matrices */
    size =  (m + 1) * (n + 1);

    d = (int *) calloc_safely( size, sizeof( int ), 
                               "occurred in lpa_align: d" );
    for ( i = 0; i < size; i++ )
        d[i] = -UNSEEN;
    backpnt = (BYTE *) calloc_safely( size, sizeof( BYTE ),
                                      "occurred in lpa_align: backpnt" );

    /* map strings to sequential codes for fast penalty matrix evaluation */
    seq1 = (char *) calloc_safely( m, sizeof( char ), "occured in lpa_align: seq1" );
    seq2 = (char *) calloc_safely( n, sizeof( char ), "occured in lpa_align: seq2" );
#ifdef DEBUG
    printf( "seq1 = %x, seq2 = %x\n", seq1, seq2 );
#endif
    char_to_sequential( char_seq1, seq1 );
    char_to_sequential( char_seq2, seq2 );
#ifdef DEBUG
    printf( "now seq1 = %x, seq2 = %x\n", seq1, seq2 );
#endif

    /* once we're confident we don't need these any more, with (5/1)        */
    /* gap start and continuation penalties, we can remove all reference to */
    /* these */
    /* estimate lead offsets */
 
#undef MAX_LEAD_OFFSETS

#ifdef MAX_LEAD_OFFSETS
    if ( n > m )
       {
        max_right_lead_offset = 1 * (n - m);
        max_down_lead_offset = m / 10;
       }
    else
       {
        max_right_lead_offset = n / 10;
        max_down_lead_offset = 1 * (m - n);
       }
#else
    max_right_lead_offset = 0;
    max_down_lead_offset = 0;
#endif

#ifdef DEBUG
    printf( "starting lpa\n" );  fflush( stdout );
#endif
    pq_init( m, n );
    pq_update( 0, 0, UNSEEN );    

    do {
        if ( ! pq_remove( &i, &j ) )
           {
            fprintf( stderr, "error: priority queue empty!\n" );
            exit( 1 );
           }
#ifdef DEBUG
        if ( (++counter % 10000) == 0 )
            printf( "%d  i,j = (%5d,%5d) dist %8d\n", counter, i, j, dist );
#endif
        if ( i < m || j < n )
	   {
            x = ind( i, j );
            d[x] = -d[x];
            if ( d[x] == UNSEEN )
                d[x] = 0;

            if ( j < n )
 	       {
                y = ind( i, j+1 );                        /* RIGHT */
                if ( d[y] < 0 )
		   {
                    if ( handle_translation )
                        gap_t_off = ( j % 3 ) ? 1 : 0;
                    else
                        gap_t_off = 0;
                    if ( i == m )
                        p = 0;
		    else if ( i == 0 && j < max_right_lead_offset )
                        p = 0;
                    else if ( backpnt[x] == LEFT )
                        p = GAPCONT; /* + gap_t_off; ?*/
                    else 
                        p = GAPSTART + gap_t_off;
#ifdef NO
                    else 
                        p = INDEL + gap_t_off;
#endif
                    dist = d[x] + p;
                    if ( pq_update( i, j+1, dist ) )
	               {
                        d[y] = -dist;
                        backpnt[y] = LEFT;
#ifdef DEBUG
                        printf( "       RIGHT, %d,         %d, %d\n",
                                                   p, dist, d[y] );
#endif
	               }
		   }
                
	       }

            if ( i < m )
	       {
                y = ind( i+1, j );                        /* DOWN */
                if ( d[y] < 0 )
		   {
                    if ( handle_translation )
                        gap_t_off = ( i % 3 ) ? 1 : 0;
                    else
                        gap_t_off = 0;
                    if ( j == n )
                        p = 0;
		    else if ( j == 0 && i < max_down_lead_offset )
                        p = 0;
                    else if ( backpnt[x] == UP )
                        p = GAPCONT;
                    else
                        p = GAPSTART + gap_t_off;
#ifdef NO
                    else 
                        p = INDEL + gap_t_off;
#endif
                    dist = d[x] + p;
                    if ( pq_update( i+1, j, dist ) )
	               {
                        d[y] = -dist;
                        backpnt[y] = UP;
#ifdef DEBUG
                        printf( "       DOWN, %d,         %d, %d\n", 
                                                   p, dist, d[y] );
#endif
	               }
		   }
	       }

            if ( i < m && j < n )
	       {
                y = ind( i+1, j+1 );                      /* DIAG */
                if ( d[y] < 0 )
		   {
     	            /*
                    if ( seq1[i] == seq2[j] )
                        p = 0;
                    else if ( ISAMB( seq1[i] ) || ISAMB( seq2[j] ) )
                        p = AMB_SUBST;
                    else
                        p = SUBST_ERR;
    		    */
                    p = penalty[seq1[i]][seq2[j]];
                    dist = d[x] + p;
                    if ( pq_update( i+1, j+1, dist ) )
	               {
                        d[y] = -dist;
                        backpnt[y] = DIAG;
#ifdef DEBUG
                        printf( "       DIAG, %d,           %d, %d\n", 
                                p, dist, d[y] );
#endif
	               }
		   }
	       }
	   }
       }
    while ( i < m || j < n );

#ifdef DEBUG
    printf( "Done lpa!\n" );
#endif

    gen_alignment( backpnt, m, n, char_seq1, char_seq2, max_align_size,
                   handle_translation, 
                   top, mid, bot, trans_top, trans_bot, l );
#ifdef DEBUG
    printf( "size is %d, align l is %d\n", size, *l );
#endif

#ifdef DEBUG
    printf( "freeing seq1 = %x, seq2 = %x\n", seq1, seq2 );
#endif

#ifdef NO
    free( d );
    free( backpnt );
    free( seq1 );
    free( seq2 );
#endif
   }



void  gen_alignment( BYTE *backpnt, int m, int n, 
                     char *seq1, char *seq2,
                     int   max_align_size,
                     int   handle_translation, 
                     char *top, char *mid, char *bot, 
                     char *trans_top, char *trans_bot, int *l )
   {
    int  i, j, k;
    char *s1, *s2;
    char *trans1, *trans2;
    char *t1, *t2;
    
    i = m;
    j = n;
    k = 0;
    s1 = seq1 + m;
    s2 = seq2 + n;
    if ( handle_translation )
       {
        trans1 = (char *) calloc_safely( strlen(seq1)+1, sizeof(char),
                                         "occured in gen_alignment: trans1" );
        trans2 = (char *) calloc_safely( strlen(seq2)+1, sizeof(char),
                                         "occured in gen_alignment: trans2" );
        translate( seq1, trans1 );
        translate( seq2, trans2 );
        t1 = trans1 + m;
        t2 = trans2 + n;
       }
    while ( k < max_align_size && (i > 0 || j > 0) )
       {
#ifdef DEBUG
        printf( "gen al: %d %d: %d\n", i, j, backpnt[ ind(i,j) ] );
#endif
        switch ( backpnt[ ind(i,j) ] )
           {
            case  UP:
                          top[k] = *--s1;
                          mid[k] = INDEL_IND;
                          bot[k] = INDEL_SPACER;
                          if ( handle_translation )
                             {
                              trans_top[k] = *--t1;
                              trans_bot[k] = INDEL_SPACER;
                             }
                          i--;
                          break;
            case  LEFT:
                          top[k] = INDEL_SPACER;
                          mid[k] = INDEL_IND;
                          bot[k] = *--s2;
                          if ( handle_translation )
                             {
                              trans_top[k] = INDEL_SPACER;
                              trans_bot[k] = *--t2;
                             }
                          j--;
                          break;
            case  DIAG:
                          top[k] = *--s1;
                          bot[k] = *--s2;
                          if ( *s1 == *s2 )
                              mid[k] = OK_IND;
                          else if ( ISAMB(SEQUENT(*s1)) || ISAMB(SEQUENT(*s2)))
                              mid[k] = AMB_IND;
                          else
                              mid[k] = WRONG_IND;
                          if ( handle_translation )
                             {
                              trans_top[k] = *--t1;
                              trans_bot[k] = *--t2;
                             }
                          i--; j--;
                          break;
	   }
        k++;
       }
    if ( k >= max_align_size )
       {
        fprintf( stderr, "%s (gen_alignment): alignment array overflow!\n",
                         progname );
        exit( 1 );
       }
    *l = k;
    if ( handle_translation )
       {
        free( trans1 );
        free( trans2 );
       }
   }

#define SUBST_TYPE      1
#define TOP_INS_TYPE    2
#define BOT_INS_TYPE    3

void  get_align_stats( char *top, char *mid, char *bot, int l, 
                       int m, int n,
                       ALIGN_STATS *s, int handle_translation,
                       char *trans_top, char *trans_bot )

   {
    int  i, k;
    int  a, b;
    int  top_pos, bot_pos;
    int  non_silent;

    s->top_end_off = s->bot_end_off = s->top_beg_off = s->bot_beg_off = 0;
    s->num_ok = s->num_wrong = s->num_indels = s->num_ambs = 0;
    s->num_seq1_inserts = s->num_seq2_inserts = 0;
    s->num_seq1_ambs = s->num_seq2_ambs = 0;

    if ( handle_translation )
       {
        s->num_wrong_x = s->num_indels_x = 0;
        s->num_seq1_inserts_x = s->num_seq2_inserts_x = 0;
       }

    /* advance past beginning offsets, and count them.  Don't forget that */
    /* top, mid & bot are backwards!                                      */
    l--;  
    while ( l >= 0 && mid[l] == INDEL_IND )
        if ( top[l--] == INDEL_SPACER )
            s->top_beg_off++;
        else
            s->bot_beg_off++;
    b = l;    

    /* l now points at first "interior" char */
    
    i = 0;
    while ( i <= l && mid[i] == INDEL_IND )
        if ( top[i++] == INDEL_SPACER )
            s->top_end_off++;
        else
            s->bot_end_off++;
    a = i;

    /* i now points at last "interior" character */

    top_pos = s->bot_beg_off + 1;  /* note the "switched" sense here */
    bot_pos = s->top_beg_off + 1;

    while ( l >= i )
       {
        if ( mid[l] != OK_IND )
           {
#ifdef DEBUG         /* This should be put into a separate routine! */
            printf( "%c: %d %c - %d %c\n", mid[l], top_pos, top[l], 
                                                   bot_pos, bot[l] );
#endif
            if ( top[l] != INDEL_SPACER )
                top_pos++;
            if ( bot[l] != INDEL_SPACER )
                bot_pos++;
           }
        else
           {
            top_pos++;
            bot_pos++;
           }
        l--;
       }
#ifdef DEBUG
    printf( "i = %d, l = %d\n", i, l );
    printf( "a = %d, b = %d\n", a, b );
    printf( "%c %c %c   %c %c %c\n", top[a], mid[a], bot[a], 
                                     top[b], mid[b], bot[b] );
#endif
    for ( k = a; k < b; k++ )
       {
        non_silent = handle_translation 
                          && ( trans_top[k] != trans_bot[k] );
        switch( mid[k] )
	   {
	    case  OK_IND:      s->num_ok++;
                               break;
            case  INDEL_IND:   s->num_indels++;
                               if ( non_silent )
                                   s->num_indels_x++;
                               if ( top[k] == INDEL_SPACER )
                                  {
                                   s->num_seq1_inserts++;
                                   if ( non_silent )
                                       s->num_seq1_inserts_x++;
                                  }
                               else
                                  {
                                   s->num_seq2_inserts++;
                                   if ( non_silent )
                                       s->num_seq2_inserts_x++;
                                  }
                               break;
            case  AMB_IND:     s->num_ambs++;
                               if ( ISAMB( top[k] ) )
                                   s->num_seq1_ambs++;
                               else
                                   s->num_seq2_ambs++;
                               break;
            case  WRONG_IND:   s->num_wrong++;
                               if ( non_silent )
                                   s->num_wrong_x++;
                               break;

	   }
       }
   }


void  print_align_stats( ALIGN_STATS *a, int handle_translation )
   {
    printf( "seq1 offsets:            %4d    %4d\n", a->top_beg_off, 
                                                     a->top_end_off );
    printf( "seq2 offsets:            %4d    %4d\n", a->bot_beg_off, 
                                                     a->bot_end_off );
    printf( "Matches:                 %4d\n", a->num_ok );
    printf( "Errors + Ambiguities:    %4d", a->num_indels + a->num_ambs
                                              + a->num_wrong );
    if ( handle_translation )
        printf( "    %4d", a->num_indels_x + a->num_ambs
                                              + a->num_wrong_x );
    printf( "\n" );

    printf( "Errors (subst + indels): %4d", a->num_indels + a->num_wrong );
    if ( handle_translation )
        printf( "    %4d", a->num_indels_x + a->num_wrong_x );
    printf( "\n" );

    printf( "Substitution Errors:     %4d", a->num_wrong );
    if ( handle_translation )
        printf( "    %4d", a->num_wrong_x );
    printf( "\n" );

    printf( "Indels:                  %4d", a->num_indels );
    if ( handle_translation )
        printf( "    %4d", a->num_indels_x );
    printf( "\n" );

    printf( "Insertions in seq 1:     %4d", a->num_seq1_inserts );
    if ( handle_translation )
        printf( "    %4d", a->num_seq1_inserts_x );
    printf( "\n" );

    printf( "Insertions in seq 2:     %4d", a->num_seq2_inserts );
    if ( handle_translation )
        printf( "    %4d", a->num_seq2_inserts_x );
    printf( "\n" );

    printf( "Ambiguity substitutions: %4d\n", a->num_ambs );
    printf( "Ambiguities in seq 1:    %4d\n", a->num_seq1_ambs );
    printf( "Ambiguities in seq 2:    %4d\n", a->num_seq2_ambs );
   }

void  repeat_out( FILE *f, char c, int m )
   {
    while ( m-- > 0 )
        putc( c, f );
   }


/* prints 1 row of top or bot position numbers */

void  print_pos_numbers( FILE *f, char *chr, int k, int *pos )
   {
    int  l;
    
    repeat_out( f, ' ', 19 - *pos % 10 );   /* labels are 18 + 1 space, then */
                                            /* deduct leftover from prev line*/
    l = 0;
    while ( k > 0 && l++ < 60 )
        if ( chr[--k] == INDEL_SPACER )
            putc( ' ', f );
        else if ( (++(*pos) % 10) == 0 )
            fprintf( f, "%10d", *pos );
    putc( '\n', f );
   }    

/* prints one 60 char row of top, mid or bot characters, with label */

void  print_row_chars( FILE *f, char *label, char *chr, int *k )
   {
    int  l;

    fprintf( f, "%-18.18s ", label );
    l = 0;
    while ( *k > 0 && l++ < 60 )
        putc( chr[--(*k)], f );
    putc( '\n', f );
   }

/* Prints out the alignment that was constructed backwards in top, */
/* mid & bot starting at position n-1                              */

void  print_alignment( FILE *f, char *top_name, char *bot_name,
                       int handle_translation,
                       char *top, char *mid, char *bot, 
                       char *trans_top, char *trans_bot, int n )

   {
    int  i, j, k;       /* top, middle and bottom array indices */
    int  i1, k1;        /* dummies for translation top and bottom */
    int  top_p;         /* top sequence position counter */
    int  bot_p;         /* bottom sequence position counter */
    int  save_k;

    i = j = k = n;      /* the top, mid and bot arrays are backwards */
    top_p = bot_p = 0;  /* but sequence positions are forwards */

    do {                /* for each course of 60 chars */

        /* first we print the top sequence positions (if any) every 10 nt */
        print_pos_numbers( f, top, i, &top_p );

        if ( handle_translation )
           {
            i1 = i;
            print_row_chars( f, " ", trans_top, &i1 );
           }

        /* next we print the top sequence */
        print_row_chars( f, top_name, top, &i );

        /* next, we print the middle (mismatches, if any) */
        print_row_chars( f, "", mid, &j );

        /* next comes the bottom sequence */
        save_k = k;
        print_row_chars( f, bot_name, bot, &k );

        if ( handle_translation )
           {
            k1 = save_k;
            print_row_chars( f, " ", trans_bot, &k1 );
           }

        /* lastly comes the bottom sequence positions (if any) every 10 nt */
        print_pos_numbers( f, bot, save_k, &bot_p );

        fprintf( f, "\n\n");   /* between courses */
       }
    while ( i > 0 );
   }

/* convention: bottom is raw, top is corrected sequence.                     */
/*    meanings:  ins - ABI made an insertion _error_                         */
/*               del - ABI made a deletion _error_                           */
/*               sub - ABI made a substition error (even if top is N)        */

void  print_diffs( ALIGN_STATS *a, int handle_translation, 
                   char *top, char *mid, char *bot, 
                   char *trans_top, char *trans_bot, int n )

   {
    int  i;       /* position counter for top (corrected) */
    int  j;       /* position counter for bot (corrected) */
    int  n_stop;  /* end of overlap region                */
    static char non_silent_f[3];

    /* remember, now, that top, mid & bot are backwards! */

    i = j = 1;
    if ( a->top_beg_off > 0 )
       {
        n -= a->top_beg_off;
        j += a->top_beg_off;
       }
    else if ( a->bot_beg_off > 0 )
       {
        n -= a->bot_beg_off;
        i += a->bot_beg_off;
       }
    n_stop = MAX( a->top_end_off, a->bot_end_off );

    while ( --n >= n_stop )
       {
        if ( handle_translation && (trans_top[n] != trans_bot[n] ) )
            strcpy( non_silent_f, " *" );
        else
            strcpy( non_silent_f, "" );
        switch( mid[n] )
	   {
	    case  OK_IND:      i++; j++;
                               break;
            case  INDEL_IND:   if ( top[n] == INDEL_SPACER )
                                   printf( "%4d %4d ins - %c%a\n", 
                                            i, j++, bot[n], non_silent_f );
                               else
                                   printf( "%4d %4d del %c -%\n", 
                                            i++, j, top[n], non_silent_f );
                               break;
            case  AMB_IND:     printf( "%4d %4d amb %c %c\n", 
                                       i++, j++, top[n], bot[n] );
                               break;
            case  WRONG_IND:   printf( "%4d %4d sub %c %c%s\n", 
                                      i++, j++, top[n], bot[n], non_silent_f );
                               break;

	   }
       }
   }



                        /***************************/
                        /* Priority Queue Routines */
                        /***************************/


#define PQ_TREE_SIZE   64000
#define MAX_PRIOR         -1

int     pq_n = 0;
int     pq_tree_dist[PQ_TREE_SIZE+1];
int     pq_tree_x[PQ_TREE_SIZE+1];
int    *pq_lkup;
short  *pq_i;
short  *pq_j;
int     pq_mat_n;
int     pq_mat_m;
int     pq_mat_size;



#define pq_ind(x,y) ((x)*(pq_mat_n+1) + (y))

void pq_init( int m, int n )

   {
    pq_mat_m = m;
    pq_mat_n = n;
    pq_mat_size = (n + 1) * (m + 1);
#ifdef DEBUG
    printf( "pq_mat size is %d\n", pq_mat_size );
#endif
    pq_lkup = (int *) calloc_safely( pq_mat_size, sizeof(int),
                                     "occurred in pq_ind: pq_lkup" );
    pq_i = (short *) calloc_safely( pq_mat_size, sizeof(short),
                                     "occurred in pq_ind: pq_i" );
    pq_j = (short *) calloc_safely( pq_mat_size, sizeof(short),
                                     "occurred in pq_ind: pq_j" );
    pq_n = 0;
   }

/* returns 1 if an insert is made or if the priority is raised     */
/* (if dist is < the current value), and returns 0 if no change is */
/* made.                                                           */

int pq_update( int i, int j, int dist )

   {
    int x, k;

    x = pq_ind(i,j);
    /* Is  i,j (x rather) in pq already? */
    if ( (k = pq_lkup[x]) > 0 )
       {
        if ( pq_tree_dist[k] <= dist )
            return( 0 );
        pq_tree_dist[k] = dist;
        pq_upheap( k );
       }
    else
       {
        if ( pq_n >= PQ_TREE_SIZE )
           {
            fprintf( stderr, "pq tree overflow, i = %d, j = %d, dist = %d\n",
                              i, j, dist );
            exit( 1 );
           }
        x = pq_ind(i,j);
        pq_tree_dist[++pq_n] = dist;
        pq_tree_x[pq_n] = x;
        pq_lkup[x] = pq_n;
        pq_i[x] = i;
        pq_j[x] = j;
        pq_upheap( pq_n );
       }

    return( 1 );
   }


int pq_remove( int *i, int *j )

   {
    int x;
    
    if ( pq_n < 1 )
        return( 0 );
    x = pq_tree_x[1];
    *i = pq_i[x];
    *j = pq_j[x];
    pq_lkup[x] = 0;   /* indicates that i,j is no longer in pq */
                      /* - used by pq_update().                */
    pq_tree_dist[1] = pq_tree_dist[pq_n];  /* now put last guy at top */
    pq_tree_x[1]    = pq_tree_x[pq_n];     
    pq_lkup[pq_tree_x[pq_n]] = 1;
    pq_n--;
    pq_downheap( 1 );                      /* and bubble him down */
    return( 1 );
   }

   
void  pq_upheap( int k )
   {
    int d, j, x;
    
    d = pq_tree_dist[k];
    x = pq_tree_x[k];
    pq_tree_dist[0] = MAX_PRIOR; 
    while ( pq_tree_dist[ j = ( k / 2 ) ] > d )
       {
        pq_lkup[ pq_tree_x[j] ] = k;
        pq_tree_dist[k] = pq_tree_dist[j];
        pq_tree_x[k] = pq_tree_x[j];
        k = j;
       }
    pq_lkup[x] = k;
    pq_tree_dist[k] = d;
    pq_tree_x[k] = x;
   }

void  pq_downheap( int k )
   {
    int d, x, j;

    d = pq_tree_dist[k];
    x = pq_tree_x[k];
    while ( k <= pq_n / 2 )
       {
        j = k + k;            /* k <<1 */
        if ( j < pq_n )
            if ( pq_tree_dist[j] > pq_tree_dist[j+1] )
                j++;
        if ( d < pq_tree_dist[j] ) 
            break;
        pq_lkup[ pq_tree_x[j] ] = k;
        pq_tree_dist[k] = pq_tree_dist[j];
        pq_tree_x[k] = pq_tree_x[j];
        k = j;
       }
     pq_tree_dist[k] = d;
     pq_tree_x[k] = x;
     pq_lkup[x] = k;
   }

#ifdef DEBUG
void pq_dump()

   {
    int i, j;
    
    printf( "pq tree size: %d\n", pq_n );
    for ( i = 0; i <= pq_n; i++ )
        printf( "%3d: %4d  (%3d %3d)\n", 
                 i, pq_tree_dist[i], pq_i[pq_tree_x[i]], 
                 pq_j[pq_tree_x[i]]);
#ifdef SUPERDEBUG
    for ( i = 1; i <= pq_mat_m; i++ )
        for ( j = 1; j <= pq_mat_n; j++ )
            printf( "(%2d %2d) [%2d] %2d (%2d %2d)\n", 
                     i, j, pq_ind(i,j), pq_lkup[pq_ind(i,j)],
                     pq_i[pq_ind(i,j)], pq_j[pq_ind(i,j)] );
#endif
   }
#endif



@


3.10
log
@added GAPSTART and GAPCONT penalties - seperate scores for starting
and continuing gaps, in the hopes this will clear up the problems
I has having with the offsets.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.9 2003/03/14 11:08:30 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.9 2003/03/14 11:08:30 mccorkle Exp mccorkle $";
d25 4
a28 2
#define  GAPSTART       50
#define  GAPCONT        10
d86 3
a88 1
                     char *top, char *mid, char *bot, int *l );
d106 1
d110 2
d127 1
d156 1
a156 2
    max_right_lead_offset = 0;
    max_down_lead_offset = 0;
d158 1
a158 1
#ifdef NO
d169 3
d202 4
d211 1
a211 1
                        p = GAPCONT;
d213 1
a213 1
                        p = GAPSTART;
d216 1
a216 1
                        p = INDEL;
d237 4
d248 1
a248 1
                        p = GAPSTART;
d251 1
a251 1
                        p = INDEL;
d300 3
a302 2
    gen_alignment( backpnt, m, n, char_seq1, char_seq2, max_align_size, 
                   top, mid, bot, l );
d324 3
a326 1
                     char *top, char *mid, char *bot, int *l )
d330 2
d338 11
d360 5
d371 5
d387 5
d404 5
d417 2
a418 1
                       ALIGN_STATS *s )
d424 1
d431 6
d489 3
d497 2
d500 1
d502 3
d506 1
d508 3
d519 2
d524 1
d528 1
a528 1
void  print_align_stats( ALIGN_STATS *a )
d535 1
a535 1
    printf( "Mismatches:              %4d\n", a->num_indels + a->num_ambs
d537 30
a566 5
    printf( "Errors:                  %4d\n", a->num_indels + a->num_wrong );
    printf( "Substitution Errors:     %4d\n", a->num_wrong );
    printf( "Indels:                  %4d\n", a->num_indels );
    printf( "Insertions in seq 1:     %4d\n", a->num_seq1_inserts );
    printf( "Insertions in seq 2:     %4d\n", a->num_seq2_inserts );
d613 3
a615 1
                       char *top, char *mid, char *bot, int n )
d619 1
d632 6
d648 6
d667 3
a669 1
void  print_diffs( ALIGN_STATS *a, char *top, char *mid, char *bot, int n )
d675 1
d694 4
d703 2
a704 2
                                   printf( "%4d %4d ins - %c\n", 
                                            i, j++, bot[n] );
d706 2
a707 2
                                   printf( "%4d %4d del %c -\n", 
                                            i++, j, top[n]  );
d712 2
a713 2
            case  WRONG_IND:   printf( "%4d %4d sub %c %c\n", 
                                       i++, j++, top[n], bot[n] );
@


3.9
log
@okay, that fix didn't work, but I think this one does (finally).
Also, modularized print_alignment() a little bit more.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.8 2003/03/13 19:42:37 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.8 2003/03/13 19:42:37 mccorkle Exp mccorkle $";
d24 6
a29 4

#define  INDEL          5  /* insertion/deletion penalty */
#define  SUB            4  /* substitution error penalty */
#define  AMB            0  /* ambiguity subsititution penalty */
d143 3
d148 4
d154 1
a154 1
        max_right_lead_offset = n - m;
d160 1
a160 1
        max_down_lead_offset = m - n;
d162 1
d196 5
d203 1
d227 5
d234 1
@


3.8
log
@tried to fix the position numbering in print_alignment() once and for all.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.7 2003/01/14 21:54:57 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.7 2003/01/14 21:54:57 mccorkle Exp mccorkle $";
d454 30
a486 2
char empty[] = { 0 };   /* this is acting up - better be careful! */

d494 1
a494 4
    int l, m, a, b;
    int q, s;
    int  r, t;

a495 2
    r = q = 0;
    t = s = 0;
d500 1
d502 1
a502 24
        repeat_out( f, ' ', q == 0 ? 19 : 19 - r );
        r = 0;
        l = 0;
        /* how far do we have to go ahead to get to the next 10? */
        a = i;
        do {
            while ( l < 60 && q < 10 )
               {
                if ( a > 0 && top[--a] != INDEL_SPACER )
                    q++;
                l++;  r++;
               }
            if ( q >= 10 )
               {
                top_p += q;
                repeat_out( f, ' ', r - 10 );
                fprintf( f, "%10d", top_p );
                q = 0;
                r = 0;
               }
           }
        while ( l < 60 );
        putc( '\n', f );

d505 1
a505 5
        fprintf( f, "%-18.18s ", top_name );
        l = 0;
        while ( i > 0 && l++ < 60 )
            putc( top[--i], f );
        putc( '\n', f );
d508 1
a508 5
        fprintf( f, "%-18.18s ", empty );
        l = 0;
        while ( j > 0 && l++ < 60 )
            putc( mid[--j], f );
        putc( '\n', f );
d511 2
a512 6
        fprintf( f, "%-18.18s ", bot_name );
        l = 0;
        b = k;                         /* must save b NOW before k is chngd*/
        while ( k > 0 && l++ < 60 )
            putc( bot[--k], f );
        putc( '\n', f );
d515 1
d517 1
a517 42
        repeat_out( f, ' ', s == 0 ? 19 : 19 - t );
        t = 0;
        m = 0;
        /* how far do we have to go ahead to get to the next 10? */
        do {
            while ( m < 60 && s < 10 )
               {
                if ( b > 0 && bot[--b] != INDEL_SPACER )
                    s++;
                m++;  t++;
               }
            if ( s >= 10 )
               {
                bot_p += s;
                repeat_out( f, ' ', t - 10 );
                fprintf( f, "%10d", bot_p );
                s = 0;
                t = 0;
               }
           }
        while ( m < 60 );
        putc( '\n', f );


        /*
        fprintf( f, "%18.18s ", "" );
        for ( l = 0; l < 60 && a > 0; l++ )
            if ( bot[--a] != INDEL_SPACER ) 
               {
                if ( ( ++bot_p % 10 ) == 0 )
                    fprintf( f, "%10d", bot_p );
               }
            else
                putc( ' ', f );
        putc( '\n', f );
        */

        fprintf( f, "\n\n");
        /* for ( l = 0; l < 79; l++ )
              putc( '_', f );
          putc( '\n', f ); */

@


3.7
log
@preping for port to Irix 6 Origin 300
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.6 2000/08/07 14:20:45 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.6 2000/08/07 14:20:45 mccorkle Exp mccorkle $";
d110 1
a110 1
    int           i, j, k;
d166 1
d169 1
d447 6
d463 28
a490 9
    int  i, j, k, l;
    int  top_p, bot_p, a, b;

    i = j = k = n;
    top_p = bot_p = 0;
    do {
        fprintf( f, "%10s", "" );
        for ( l = 0, a = i; l < 60 & a > 0; l++  )
            if ( top[--a] != INDEL_SPACER ) 
d492 5
a496 2
                if ( ( ++top_p % 10 ) == 0 )
                    fprintf( f, "%10d", top_p );
d498 2
a499 2
            else
                putc( ' ', f );
d501 3
d510 1
d517 1
d520 1
d524 24
a547 2
        for ( l = 0; l < 79; l++ )
            putc( '_', f );
d549 20
@


3.6
log
@now using calloc_safely().
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.4 2000/03/22 01:02:50 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.4 2000/03/22 01:02:50 mccorkle Exp mccorkle $";
d130 5
a134 2
    seq1 = calloc_safely( m, sizeof( char ), "occured in lpa_align: seq1" );
    seq2 = calloc_safely( n, sizeof( char ), "occured in lpa_align: seq2" );
d137 3
d264 5
d273 1
d456 1
d459 1
d461 10
@


3.5
log
@changed print_alignment() so that it can print to a file.
@
text
@d25 1
a25 1
#define  INDEL          8  /* insertion/deletion penalty */
d27 1
a27 1
#define  AMB            1  /* ambiguity subsititution penalty */
d117 1
d121 3
a123 2
    /* put in check for null returns (not enough memory) */
    d = (int *) calloc( size, sizeof( int ) );
d126 2
a127 1
    backpnt = (BYTE *) calloc( size, sizeof( BYTE ) );
d130 2
a131 2
    seq1 = calloc( m, sizeof( char ) );
    seq2 = calloc( n, sizeof( char ) );
d160 2
a161 1

d529 2
a530 2
#define PQ_TREE_SIZE   8000
#define MAX_PRIOR        -1
d555 6
a560 3
    pq_lkup = (int *) calloc( pq_mat_size, sizeof(int) );
    pq_i = (short *) calloc( pq_mat_size, sizeof(short) );
    pq_j = (short *) calloc( pq_mat_size, sizeof(short) );
@


3.4
log
@cosmetic changes - fixed spelling in print_align_stats() and tidied
things up a bit.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.3 2000/03/21 20:43:11 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.3 2000/03/21 20:43:11 mccorkle Exp mccorkle $";
d46 1
a46 1
       X,   X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,  X,
d435 1
a435 1
void  print_alignment( char *top_name, char *bot_name,
d443 1
a443 1
        printf( "%-18.18s ", top_name );
d446 2
a447 2
            putchar( top[--i] );
        putchar( '\n' );
d449 1
a449 1
        printf( "%-18.18s ", empty );
d452 2
a453 2
            putchar( mid[--j] );
        putchar( '\n' );
d455 1
a455 1
        printf( "%-18.18s ", bot_name );
d458 2
a459 2
            putchar( bot[--k] );
        putchar( '\n' );
d461 2
a462 2
            putchar( '_' );
        putchar( '\n' );
@


3.3
log
@fixed bug with ambiguity/subs error counting.  Cosmetics.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.2 2000/03/16 19:58:33 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.2 2000/03/16 19:58:33 mccorkle Exp mccorkle $";
d412 6
a417 4
    printf( "seq1 offsets:  %d  %d\n", a->top_beg_off, a->top_end_off );
    printf( "seq2 offsets:  %d  %d\n", a->bot_beg_off, a->bot_end_off );
    printf( "Matches:               %3d\n", a->num_ok );
    printf( "Mismatches:            %3d\n", a->num_indels + a->num_ambs
d419 8
a426 8
    printf( "Errors:                %3d\n", a->num_indels + a->num_wrong );
    printf( "Substitution Errors:   %3d\n", a->num_wrong );
    printf( "Indels:                %3d\n", a->num_indels );
    printf( "Insertions in seq 1:   %3d\n", a->num_seq1_inserts );
    printf( "Insertions in seq 2:   %3d\n", a->num_seq2_inserts );
    printf( "Ambiguity substitions: %3d\n", a->num_ambs );
    printf( "Ambiguities in seq 1:  %3d\n", a->num_seq1_ambs );
    printf( "Ambiguities in seq 2:  %3d\n", a->num_seq2_ambs );
@


3.2
log
@many differences.  Dusting this off, porting to linux
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.1 1997/09/30 05:20:09 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.1 1997/09/30 05:20:09 mccorkle Exp mccorkle $";
d299 1
a299 1
                          else if ( ISAMB(*s1) || ISAMB(*s2) )
d418 1
a418 1
    printf( "Substition Errors:     %3d\n", a->num_wrong );
d678 3
@


3.1
log
@Added penalty-matrix handling for all ambiguity codes (not just Ns).
This entailed an additional translation from character strings to
sequential codes.
@
text
@d6 1
a6 1
/* $Id: lpa_align.c,v 3.0 1997/04/22 01:35:25 mccorkle Exp mccorkle $ */
d10 1
a10 1
      "$Id: lpa_align.c,v 3.0 1997/04/22 01:35:25 mccorkle Exp mccorkle $";
a39 2
                                /* need to spruce this up for other amb codes*/
#define  ISAMB(x)       ( (x) > 4 )
a40 1
#define X -1    /* not allowed */
a82 1
void char_to_sequential( char *characters, char *sequential );
a515 36

/* Used by char_to_sequential to quickly map ascii characters to a 1-15 */
/* sequential code */


char seq_map[] = {
                  /*          0     1     2     3     4     5     6     7   */
                  /* 000 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 010 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 020 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 030 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 040 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 050 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 060 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 070 */   X,    X,    X,    X,    X,    X,    X,    X,
                  /* 100 */   X,    1,   14,    2,   13,    X,    X,    3,
                  /* 110 */  12,    X,    X,   10,    X,    5,   15,    X,
                  /* 120 */   X,    X,    6,    8,    4,    X,   11,    7,
                  /* 130 */   X,    9,    X,    X,    X,    X,    X,    X,
                  /* 140 */   X,    1,   14,    2,   13,    X,    X,    3,
                  /* 150 */  12,    X,    X,   10,    X,    5,   15,    X,
                  /* 160 */   X,    X,    6,    8,    4,    X,   11,    7,
                  /* 170 */   X,    9,    X,    X,    X,    X,    X,    X,
                 };

/* char_to_sequential() translates a DNA character sequence, character-by-  */
/* character, to a sequential mapping, according to the scheme              */
/* a -> 1, c-> 2, g -> 3, t -> 4, m -> 5, r -> 6, ..., n -> 15              */
/* Note: the calling routine is responsible for string allocation           */

void char_to_sequential( char *characters, char *sequential )
   {
    while ( *characters )
        *sequential++ = seq_map[ *characters++ ];
    *sequential = '\0';
   }
@


3.0
log
@This version seems to be working okay - it performs a Least Path
search through a 2-D comparison matrix, with no error penalty
for indels along the outside edge.  LPA uses a priority queue
which is implemented as a b-tree.
@
text
@d6 1
a6 1
/* $Id$ */
d10 1
a10 1
      "$Id$";
d25 3
a27 3
#define  INDEL          8
#define  SUBST_ERR      4
#define  AMB_SUBST      1
d41 1
a41 1
#define  ISAMB(x)       ( (x) == 'n' || (x) == 'N' )
d43 24
d86 1
d101 3
a103 3
void lpa_align( char *seq1, int m,    /* first (top) sequence & length */
                char *seq2, int n,    /* 2nd (bottom) sequence & length */
                int   max_align_size, /* max length of top, mid, bot */
d107 1
a107 1
                int  *l               /* resultant length of top, mid, bot */
d120 1
d130 6
d223 1
d230 2
d252 1
a252 1
    gen_alignment( backpnt, m, n, seq1, seq2, max_align_size, 
d260 2
d519 38
@
